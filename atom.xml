<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chance</title>
  <icon>https://www.gravatar.com/avatar/3458ca35c2ea49bdfd4dd2f81d6274b4</icon>
  <subtitle>不以物喜，不以己悲。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chanceli.com/"/>
  <updated>2020-04-06T15:57:15.066Z</updated>
  <id>http://chanceli.com/</id>
  
  <author>
    <name>Chance</name>
    <email>lc@chanceli.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter笔记之环境配置</title>
    <link href="http://chanceli.com/Flutter%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://chanceli.com/Flutter笔记之环境配置/</id>
    <published>2020-04-06T15:34:00.000Z</published>
    <updated>2020-04-06T15:57:15.066Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter笔记之环境配置<br><a id="more"></a></p><p>Android Studio 下载地址：<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">https://developer.android.google.cn/studio</a><br>Flutter SDK 下载地址：<a href="https://flutter.dev/docs/get-started/install/macos" target="_blank" rel="noopener">https://flutter.dev/docs/get-started/install/macos</a></p><h1 id="配置Flutter-SDK"><a href="#配置Flutter-SDK" class="headerlink" title="配置Flutter SDK"></a>配置Flutter SDK</h1><p>添加用户环境变量<br>打开终端，输入<code>vim ~/.bash_profile</code>,回车，编辑/.bash_profile文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>点击i进入编辑模式。<br>将如下环境变量加入到用户环境变量中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=`pwd`/flutter/bin:$PATH</span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>编辑完成，点击“Esc键，退出insert模式”, 然后输入“:wq”,回车，保存成功。<br>输入<code>source ~/.bash_profile</code>，让环境变量生效。</p><p>输入<code>echo $PATH</code>,查看环境变量，发现添加成功。 </p><p>输入<code>flutter-h</code>查看是否配置成功。</p><p>运行<code>flutter doctor</code>检测环境。</p><h2 id="Android-Studio-3-6-1-Android-sdkmanager-tool-not-found-的问题"><a href="#Android-Studio-3-6-1-Android-sdkmanager-tool-not-found-的问题" class="headerlink" title="Android Studio 3.6.1 Android sdkmanager tool not found 的问题"></a>Android Studio 3.6.1 Android sdkmanager tool not found 的问题</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>执行<code>flutter doctor</code>后提示 Android license status unknown.<br>执行 <code>flutter doctor --android-licenses</code>后提示<br>Android sdkmanager tool not found<br><img src="https://objc.vip/images/flutter/1.jpg" alt="图1 Android sdkmanager tool not found"></p><h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p>Android Studio 3.6.1版本没有tools文件夹。sdkmanager是在Android/sdk/cmdline-tools/latest/bin/sdkmanager路径下。<br><img src="https://objc.vip/images/flutter/2.jpg" alt="图2 新版本没有tools文件夹"></p><p><img src="https://objc.vip/images/flutter/3.jpg" alt="图3 新版本sdkmanager的路径"></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>找到偏好设置里Android SDK下的隐藏废弃包取消掉，下载废弃的Android SDK Tools（Obsolete）。<br>Preferences-Appearance &amp; Behavior-System Settings-Android SDK-SDK Tools<br>把 Hide Obsolete Packages 前边的对勾取消掉。这时候会显示出隐藏的废弃包Android SDK Tools（Obsolete）。勾选上后，点击Apply下载Android SDK Tools。下载完成后问题得以解决。<br><img src="https://objc.vip/images/flutter/4.jpg" alt="图4 下载 Android SDK Tools（Obsolete）"></p><p>参考链接：<a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">入门: 在macOS上搭建Flutter开发环境 - Flutter中文网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter笔记之环境配置&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://chanceli.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://chanceli.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Dart笔记</title>
    <link href="http://chanceli.com/Dart%E7%AC%94%E8%AE%B0/"/>
    <id>http://chanceli.com/Dart笔记/</id>
    <published>2020-03-02T10:06:00.000Z</published>
    <updated>2020-03-22T12:56:07.890Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter之Dart笔记<br><a id="more"></a></p><h1 id="1-入口方法、变量、常量"><a href="#1-入口方法、变量、常量" class="headerlink" title="1. 入口方法、变量、常量"></a>1. 入口方法、变量、常量</h1><h2 id="1-1-入口方法main方法"><a href="#1-1-入口方法main方法" class="headerlink" title="1.1 入口方法main方法"></a>1.1 入口方法main方法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-常量变量"><a href="#1-2-常量变量" class="headerlink" title="1.2 常量变量"></a>1.2 常量变量</h2><ul><li>var 变量</li><li>const 常量</li><li>final 常量</li></ul><h3 id="const-与-final区别"><a href="#const-与-final区别" class="headerlink" title="const 与 final区别"></a>const 与 final区别</h3><p>final 可以开始不赋值，只能赋值一次；而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化。</p><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h1><h2 id="2-1-字符串类型-String"><a href="#2-1-字符串类型-String" class="headerlink" title="2.1 字符串类型 String"></a>2.1 字符串类型 String</h2><p>字符串定义可以用单引号，“” 也可以用‘双引号’，成对出现。</p><p>String str1 = ‘this is str1’;</p><p>三个单引号（双引号）  可以定义多行字符串</p><p>字符串的拼接<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>($str1 $str2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1 + str2);</span><br></pre></td></tr></table></figure></p><h2 id="2-2-数值类型-int-double"><a href="#2-2-数值类型-int-double" class="headerlink" title="2.2 数值类型 int double"></a>2.2 数值类型 int double</h2><p>int<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 123</span><br><span class="line"></span><br><span class="line">double b = 23.5</span><br><span class="line"></span><br><span class="line">print(a);</span><br></pre></td></tr></table></figure></p><p>double既可以是整型 也可以是浮点型</p><h2 id="2-3-布尔类型-bool"><a href="#2-3-布尔类型-bool" class="headerlink" title="2.3 布尔类型 bool"></a>2.3 布尔类型 bool</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l1 = [<span class="string">'aaa'</span>,<span class="string">'bbb'</span>,<span class="string">'ccc'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1.length);</span><br></pre></td></tr></table></figure><h2 id="2-4-集合类型-List"><a href="#2-4-集合类型-List" class="headerlink" title="2.4 集合类型 List"></a>2.4 集合类型 List</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> l2 = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line">l2.add(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l3 = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">l3.add(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l3);</span><br></pre></td></tr></table></figure><h2 id="2-5-Map类型-Map"><a href="#2-5-Map类型-Map" class="headerlink" title="2.5 Map类型 Map"></a>2.5 Map类型 Map</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"name"</span>:<span class="string">"张三"</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"age"</span>:<span class="number">20</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"work"</span>:[<span class="string">"程序员"</span>,<span class="string">"快递员"</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">p[<span class="string">"name"</span>] = <span class="string">"李四"</span>;</span><br></pre></td></tr></table></figure><h2 id="2-6-类型判断"><a href="#2-6-类型判断" class="headerlink" title="2.6 类型判断"></a>2.6 类型判断</h2><p>is 关键字判断类型</p><h1 id="3-算数运算符"><a href="#3-算数运算符" class="headerlink" title="3. 算数运算符"></a>3. 算数运算符</h1><h2 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ - * / </span><br><span class="line">~/ 取整</span><br></pre></td></tr></table></figure><h2 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h2><p>关系运算符 == != &gt; &lt; &gt;= &lt;=</p><h2 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3 逻辑运算符"></a>3.3 逻辑运算符</h2><p>逻辑运算符 ! &amp;&amp; ||</p><h2 id="3-4-赋值运算符"><a href="#3-4-赋值运算符" class="headerlink" title="3.4 赋值运算符"></a>3.4 赋值运算符</h2><p>赋值运算符 == ??=  从右向左<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> b;</span><br><span class="line"></span><br><span class="line">b ??= <span class="number">23</span>; <span class="comment">//如果b为空 把23赋值给b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+= -= *=  /=  ~/=</span></span><br><span class="line">a += <span class="number">3</span>;  a = a+<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><h2 id="3-5-条件表达式"><a href="#3-5-条件表达式" class="headerlink" title="3.5 条件表达式"></a>3.5 条件表达式</h2><p>条件表达式  if else switch case<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三目运算符  ? :</p><p>?? 运算符</p><h2 id="3-6-类型转换"><a href="#3-6-类型转换" class="headerlink" title="3.6 类型转换"></a>3.6 类型转换</h2><p>数值类型转换成String  toString()  </p><p>String转换成int  int.parse()</p><p>try catch</p><p>其他类型转换布尔类型</p><p>isEmpty：判断字符串是否为空</p><p>NaN not a number isNaN 是否是数值</p><p>自增自减 ++ – 在赋值运算中，如果++在前边，先运算后赋值。如果++在后边，先赋值后运算。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a++;  <span class="comment">//a=a+1;</span></span><br><span class="line"></span><br><span class="line">a--; <span class="comment">//a = a-1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a); <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b):<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h1 id="4-循环语句"><a href="#4-循环语句" class="headerlink" title="4. 循环语句"></a>4. 循环语句</h1><h2 id="4-1-for循环"><a href="#4-1-for循环" class="headerlink" title="4.1 for循环"></a>4.1 for循环</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先执行print(i) 再执行i++</span></span><br></pre></td></tr></table></figure><h2 id="4-2-while-do…while"><a href="#4-2-while-do…while" class="headerlink" title="4.2 while do…while"></a>4.2 while do…while</h2><p>while(){</p><p>}</p><p>do{</p><p>}while()</p><h2 id="4-3-break-continue-用法区别"><a href="#4-3-break-continue-用法区别" class="headerlink" title="4.3 break continue 用法区别"></a>4.3 break continue 用法区别</h2><p>break 跳出当前循环，只能跳出一层循环</p><p>continue 跳过当次循环，循环还会继续执行</p><h1 id="5-List-Set-Map"><a href="#5-List-Set-Map" class="headerlink" title="5. List Set Map"></a>5. List Set Map</h1><h2 id="5-1-List"><a href="#5-1-List" class="headerlink" title="5.1 List"></a>5.1 List</h2><p>属性</p><ul><li>length</li><li>isEmpty</li><li>isNotEmpty</li><li>reversed  对列表倒序排序</li></ul><p>方法</p><ul><li><p>add(‘桃子’) 增加元素</p></li><li><p>addAll() 增加数组里的元素</p></li><li><p>indexOf(‘苹果’) 查找数据  查找不到返回-1 找到返回index</p></li><li><p>remove(‘西瓜’)</p></li><li><p>fillRange 修改</p></li><li><p>insert 插入</p></li><li><p>insertAll 插入多个</p></li><li><p>myList.join(‘’) //list转换成字符串</p></li><li><p>str.split(‘-‘) 字符串转换成list</p></li></ul><h2 id="5-2-Set"><a href="#5-2-Set" class="headerlink" title="5.2 Set"></a>5.2 Set</h2><p>Set 集合 去重</p><h2 id="5-3-Map"><a href="#5-3-Map" class="headerlink" title="5.3 Map"></a>5.3 Map</h2><p>常用属性</p><ul><li><p>keys</p></li><li><p>values</p></li><li><p>isEmpty</p></li><li><p>isNotEmpty</p></li></ul><p>常用方法</p><ul><li><p>addAll</p></li><li><p>remove</p></li><li><p>containsValue</p></li></ul><h2 id="5-4-forEach-map-where-any-every"><a href="#5-4-forEach-map-where-any-every" class="headerlink" title="5.4 forEach map where any every"></a>5.4 forEach map where any every</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myList.forEach((value) &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"%value"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>map</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> myList = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newList = myList.map((value)&#123;</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(newList.toList());<span class="comment">//[2,6,8]</span></span><br></pre></td></tr></table></figure><p>where</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> myList = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> newList = myList.where((value)&#123;</span><br><span class="line">  <span class="keyword">return</span> value&gt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(newList.toList());<span class="comment">//[7,8,9]</span></span><br></pre></td></tr></table></figure><p>any </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> myList = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> f = myList.any((value)&#123; <span class="comment">//只要集合里面有满足条件的就返回true</span></span><br><span class="line">  <span class="keyword">return</span> value&gt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(f);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>every</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> myList = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> f = myList.every((value)&#123; <span class="comment">//每一个都满足条件返回true，否则返回false</span></span><br><span class="line">  <span class="keyword">return</span> value&gt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(f);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h1 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h1><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>返回类型 方法名称（参数1，参数2，…） {<br>方法体<br>return 返回值；<br>}</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printInfo()&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'我是一个自定义方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> getNum() &#123;</span><br><span class="line"><span class="keyword">var</span> myNum = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">return</span> myNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = getNum();</span><br><span class="line"><span class="built_in">print</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span> getList() &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">'111'</span>,<span class="string">'222'</span>,<span class="string">'333'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数，默认参数"><a href="#可选参数，默认参数" class="headerlink" title="可选参数，默认参数"></a>可选参数，默认参数</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可选参数</span></span><br><span class="line"><span class="built_in">String</span> printUserInfo(<span class="built_in">String</span> username,[<span class="built_in">String</span> sex = <span class="string">'男'</span>,<span class="built_in">int</span> age]) &#123;<span class="comment">//[可选参数]</span></span><br><span class="line">  <span class="keyword">if</span> (age != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"姓名：<span class="subst">$username</span>---年龄：<span class="subst">$age<span class="string">";</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return "</span></span>姓名：<span class="subst">$username</span>---年龄保密"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(printUserInfo(<span class="string">"张三"</span>,<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> printUserInfo(<span class="built_in">String</span> username,&#123;<span class="built_in">String</span> sex = <span class="string">'男'</span>,<span class="built_in">int</span> age&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (age != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"姓名：<span class="subst">$username</span>---年龄：<span class="subst">$age<span class="string">";</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return "</span></span>姓名：<span class="subst">$username</span>---年龄保密"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(printUserInfo(<span class="string">"张三"</span>,age:<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h2 id="方法当做参数"><a href="#方法当做参数" class="headerlink" title="方法当做参数"></a>方法当做参数</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = ()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'我是一个匿名方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line">fn1() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'fn1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn2(fn) &#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">fn2(fn1);</span><br></pre></td></tr></table></figure><h2 id="箭头函数-只能写一行"><a href="#箭头函数-只能写一行" class="headerlink" title="箭头函数(只能写一行)"></a>箭头函数(只能写一行)</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> list = [<span class="string">'苹果'</span>,<span class="string">'香蕉'</span>,<span class="string">'西瓜'</span>];</span><br><span class="line"><span class="comment">//常规写法</span></span><br><span class="line">list.forEach((value)&#123;</span><br><span class="line"><span class="built_in">print</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line">list.<span class="keyword">for</span>((value)=&gt;<span class="built_in">print</span>(value));</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> list = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//常规写法</span></span><br><span class="line"><span class="keyword">var</span> newList = list.map((value)&#123;</span><br><span class="line">  <span class="keyword">if</span> (value &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">var</span> newList = list.map((value)=&gt;value&gt;<span class="number">2</span>?value*<span class="number">2</span>:value);</span><br><span class="line"><span class="built_in">print</span>(newList.toList());</span><br></pre></td></tr></table></figure><h2 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNum = ()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">123</span>);</span><br><span class="line">&#125;;</span><br><span class="line">printNum();</span><br></pre></td></tr></table></figure><h2 id="自执行方法"><a href="#自执行方法" class="headerlink" title="自执行方法"></a>自执行方法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((<span class="built_in">int</span> n)&#123;</span><br><span class="line"><span class="built_in">print</span>(n);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'我是自执行方法'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="方法的递归"><a href="#方法的递归" class="headerlink" title="方法的递归"></a>方法的递归</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span>;</span><br><span class="line">fn(n) &#123;</span><br><span class="line">  sum *= n;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fn(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>常驻内存，不污染全局</p><p>1.全局变量特点：全局变量常驻内存、全局变量污染全局</p><p>2.局部变量特点：不常住内存会被垃圾机制回收、不会污染全局</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">/*不会污染全局 常驻内存*/</span></span><br><span class="line">  <span class="keyword">return</span>() &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = fn();</span><br><span class="line">b(); <span class="comment">//124</span></span><br><span class="line">b(); <span class="comment">//125</span></span><br><span class="line">b(); <span class="comment">//126</span></span><br></pre></td></tr></table></figure><h1 id="7-类"><a href="#7-类" class="headerlink" title="7. 类"></a>7. 类</h1><h2 id="默认构造函数-命名构造函数"><a href="#默认构造函数-命名构造函数" class="headerlink" title="默认构造函数 命名构造函数"></a>默认构造函数 命名构造函数</h2><p>默认构造函数只能定义一个<br>命名构造函数可以定义多个</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="built_in">String</span> name;</span><br><span class="line"><span class="built_in">int</span> age;</span><br><span class="line">  <span class="comment">//默认构造函数</span></span><br><span class="line">  Person(<span class="built_in">String</span> name,<span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'这是构造函数里面的内容，这个方法在实例化的时候触发'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认构造函数简写 Person(this.name,this.age);</span></span><br><span class="line">  Person.now()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'我是命名构造函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">void</span> getInfo() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span>---<span class="subst">$age<span class="string">");</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">print("</span></span><span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">void</span> setInfo(<span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> person(<span class="string">'张三'</span>,<span class="number">20</span>);</span><br><span class="line">  <span class="built_in">print</span>(p1.name);</span><br><span class="line">  p1.setInfo(<span class="number">28</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有属性、私有方法"><a href="#私有属性、私有方法" class="headerlink" title="私有属性、私有方法"></a>私有属性、私有方法</h2><p>使用<code>_</code>把一个属性或者方法定义成私有。需要把类抽离成一个文件</p><h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter setter"></a>getter setter</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  Rect(<span class="keyword">this</span>.height,<span class="keyword">this</span>.width);</span><br><span class="line">  <span class="keyword">get</span> area&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height*<span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> areaHeight(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  Rect r = <span class="keyword">new</span> Rect(<span class="number">10</span>,<span class="number">4</span>);</span><br><span class="line">  r.areaHeight = <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"面积:<span class="subst">$&#123;r.area&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的初始化列表"><a href="#类的初始化列表" class="headerlink" title="类的初始化列表"></a>类的初始化列表</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> height;</span><br><span class="line">  <span class="built_in">int</span> width;</span><br><span class="line">  Rect():height=<span class="number">2</span>,width=<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.height&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.width&#125;</span>"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">get</span> area&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height*<span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> areaHeight(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  Rect r = <span class="keyword">new</span> Rect();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"面积:<span class="subst">$&#123;r.area&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类中的静态成员"><a href="#类中的静态成员" class="headerlink" title="类中的静态成员"></a>类中的静态成员</h2><p>1.使用<code>static</code>关键字来实现类级别的变量和函数</p><p>2.静态方法不能访问非静态成员，非静态方法可以访问静态成员</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> name = <span class="string">'张三'</span>;</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> show() &#123;</span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123; <span class="comment">/*非静态方法可以访问静态成员以及非静态成员*/</span></span><br><span class="line">    <span class="built_in">print</span>(name); <span class="comment">//访问静态属性</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">this</span>.age); <span class="comment">//访问非静态属性</span></span><br><span class="line">    show();<span class="comment">//调用静态方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> printUserInfo() &#123;<span class="comment">//静态方法</span></span><br><span class="line">    <span class="built_in">print</span>(name);<span class="comment">//静态属性</span></span><br><span class="line">    show();<span class="comment">//静态方法</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(Person.name);</span><br><span class="line">  Person.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象操作符"><a href="#对象操作符" class="headerlink" title="对象操作符"></a>对象操作符</h2><p>? 条件运算符</p><p>as 类型转换</p><p>is 类型判断</p><p>.. 级联操作（连缀）</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="? 条件运算符"></a>? 条件运算符</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">num</span> age;</span><br><span class="line">  Person(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">  Person p;</span><br><span class="line">  p?.printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="as-类型转换"><a href="#as-类型转换" class="headerlink" title="as 类型转换"></a>as 类型转换</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1;</span><br><span class="line">p1 = <span class="string">''</span>;</span><br><span class="line">p1 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>,<span class="number">20</span>);</span><br><span class="line">(p1 <span class="keyword">as</span> Person).printInfo();</span><br></pre></td></tr></table></figure><h3 id="级联操作"><a href="#级联操作" class="headerlink" title=".. 级联操作"></a>.. 级联操作</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> pERSON(<span class="string">'张三'</span>,<span class="number">20</span>);</span><br><span class="line">p1.printInfo();</span><br><span class="line">p1..name = <span class="string">"李四"</span></span><br><span class="line">  ..age = <span class="number">30</span></span><br><span class="line">  ..printInfo();</span><br></pre></td></tr></table></figure><h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> sex;</span><br><span class="line">Web(<span class="built_in">String</span> name,<span class="built_in">num</span> age,<span class="built_in">String</span> sex) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//覆写父类的方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>---年龄:<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类：主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。</p><p>抽象方法  没有方法体的方法</p><ul><li>子类必须实现</li><li>抽象类不能被实例化</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  eat(); <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>允许将子类类型的指针赋值给父类类型的指针，同一个函数调用会有不同的执行结果。</p><p>子类的实例赋值给父类的引用。</p><p>多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">d.eat();</span><br><span class="line">Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line">c.eat();</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用抽象类定义接口</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Db</span> </span>&#123; <span class="comment">//当做接口 接口：就是约定、规范</span></span><br><span class="line">  <span class="built_in">String</span> uri;</span><br><span class="line">  add();</span><br><span class="line">  save();</span><br><span class="line">  delete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span> <span class="keyword">implements</span> <span class="title">Db</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> uri;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  add() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  delete() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  save() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends抽象类和implements的区别："><a href="#extends抽象类和implements的区别：" class="headerlink" title="extends抽象类和implements的区别："></a>extends抽象类和implements的区别：</h3><p>1.如果要复用抽象类里面的方法，并且要用抽象方法约束子类的话就用extends继承抽象类。</p><p>2.如果只是把抽象类当做标准的话就用implements实现抽象类。</p><h2 id="一个类实现多个接口"><a href="#一个类实现多个接口" class="headerlink" title="一个类实现多个接口"></a>一个类实现多个接口</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  printA();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  printB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  printA() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  printB() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mixins实现类似多继承的功能"><a href="#mixins实现类似多继承的功能" class="headerlink" title="mixins实现类似多继承的功能"></a>mixins实现类似多继承的功能</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> printA() &#123;</span><br><span class="line">    <span class="built_in">String</span> info = <span class="string">"this is A"</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> printB() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">  c.printA();</span><br><span class="line">  C.printB();</span><br><span class="line">  <span class="built_in">print</span>(c.info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8. 泛型"></a>8. 泛型</h1><p>解决类 接口 方法的复用性、以及对不特定数据类型的支持（类型校验）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line">T getData&lt;T&gt;(T value) &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  getData&lt;<span class="built_in">String</span>&gt;(<span class="string">'你好'</span>);</span><br><span class="line">  <span class="built_in">print</span>(getData&lt;<span class="built_in">int</span>&gt;(<span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="built_in">List</span> list = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter之Dart笔记&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://chanceli.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://chanceli.com/tags/Flutter/"/>
    
      <category term="Dart" scheme="http://chanceli.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》五</title>
    <link href="http://chanceli.com/DataStructurePart5/"/>
    <id>http://chanceli.com/DataStructurePart5/</id>
    <published>2019-09-15T15:55:00.000Z</published>
    <updated>2020-03-22T12:25:25.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-树"><a href="#第6章-树" class="headerlink" title="第6章 树"></a>第6章 树</h1><p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p><a id="more"></a><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><blockquote><p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p></blockquote><h3 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h3><p>树的结点包含一个数据元素及若干指向其子树的分支。</p><p>结点拥有的子树数称为结点的度（Degree）。度为 0 的结点称为叶结点（Leaf）或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p><h3 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h3><p>结点的子树的根称为该结点的孩子（Child），相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之前互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p><h3 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h3><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 1 层，则其子树的根就在第 i+1 层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。</p><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><p>森林（Forest）是 m（m≥0）棵互不相交的树的集合。</p><p>线性表与树结构</p><table><thead><tr><th style="text-align:center">线性结构</th><th style="text-align:center">树结构</th></tr></thead><tbody><tr><td style="text-align:center">第一个数据元素：无前驱</td><td style="text-align:center">根结点：无双亲，唯一</td></tr><tr><td style="text-align:center">最后一个数据元素：无后继</td><td style="text-align:center">叶结点：无孩子，可以多个</td></tr><tr><td style="text-align:center">中间元素：一个前驱一个后继</td><td style="text-align:center">中间结点：一个双亲多个孩子</td></tr></tbody></table><h2 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h2><p>ADT 树（tree）</p><p>Data</p><p>  树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。</p><p>Operation</p><p>  InitTree(*T):构造空树 T。</p><p>  DestroyTree(*T):销毁树 T。</p><p>  CreateTree(*T, definition):按 definition 中给出树的定义来构造树。</p><p>  ClearTree(*T):若树 T 存在，则将树 T 清为空树。</p><p>  TreeEmpty(*T):若 T 为空树，返回 true，否则返回 false。</p><p>  TreeDepth(T):返回 T 的深度。</p><p>  Root(T):返回树的根结点。</p><p>  Value(T, cur_e):cur_e 是树 T 中一个结点，返回此结点的值。</p><p>  Assign(T, cur_e,value):给树 T 的结点 cur_e 赋值为 value。</p><p>  Parent(T, cur_e):若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。</p><p>  LeftChild(T, cur_e):若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。</p><p>  RightSibling(T, cur_e):若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。</p><p>  InsertChild(<em>T, </em>p, i, c):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。</p><p>  DeleteChild(<em>T, </em>p, i):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。</p><p>endADT</p><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器表示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p><p>以下是我们的双亲表示法的结点结构定义代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的双亲表示法结点结构定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType; <span class="comment">/* 树结点的数据类型，目前暂定为整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">  <span class="keyword">int</span> parent; <span class="comment">/* 双亲位置 */</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  /* 树结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE]; <span class="comment">/* 结点数组 */</span></span><br><span class="line">  <span class="keyword">int</span> r,n;  <span class="comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125; PTree</span><br></pre></td></tr></table></figure><p>存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。</p><p>孩子表示法。把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，放进一个一维数组中。</p><p>以下是我们的孩子表示法的结构定义代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子表示法结构定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> /* 孩子结点 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> child;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 表头结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 树结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE]; <span class="comment">/* 结点数组 */</span></span><br><span class="line">  <span class="keyword">int</span> r,n; <span class="comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p><p>结构定义代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子兄弟表示法结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">fistchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树（Binary Tree）是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>二叉树的特点有：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者一棵子树都是可以的。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。</li></ul><p>二叉树具有五种基本形态：</p><ol><li>空二叉树。</li><li>只有一个根结点。</li><li>根结点只有左子树。</li><li>根结点只有右子树。</li><li>根结点既有左子树又有右子树。</li></ol><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><h4 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1. 斜树"></a>1. 斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><h4 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2. 满二叉树"></a>2. 满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。</p><p>满二叉树的特点有：</p><p>（1）叶子只能出现在最下一层。</p><p>（2）非叶子结点的度一定是 2。</p><p>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。</p><h4 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3. 完全二叉树"></a>3. 完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p>完全二叉树的特点：</p><p>（1）叶子结点只能出现在最下两层。</p><p>（2）最下层的叶子一定集中在左部连续位置。</p><p>（3）倒数二层，若有叶子结点，一定都在右部连续位置。</p><p>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</p><p>（5）同样结点的二叉树，完全二叉树的深度最小。</p><p>判断某个二叉树是否是完全二叉树的办法，就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树的性质1"><a href="#二叉树的性质1" class="headerlink" title="二叉树的性质1"></a>二叉树的性质1</h3><p>性质1：在二叉树的第 i 层上至多有 2<sup>i-1</sup> 个结点（i≥1）。</p><h3 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h3><p>性质2：深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点（k≥1）。</p><h3 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h3><p>性质3：对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1。</p><h3 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h3><p>性质4：具有 n 个结点的完全二叉树的深度为 ⎣log<sub>2</sub>n⎦+1 ( ⎣x⎦表示不大于 x 的最大整数)。</p><p>注：⎣⎦ 向下取整运算。</p><h3 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h3><p>性质5：如果对于一棵有 n 个结点的完全二叉树（其深度为 ⎣log<sub>2</sub>n⎦+1）的结点按层序编号（从第 1 层到第 ⎣log<sub>2</sub>n⎦+1 层），每层从左到右，对任一结点 i （1≤i≤n）有：</p><ol><li>如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点 ⎣i/2⎦。</li><li>如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。</li><li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li></ol><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h3><p>顺序存储结构一般只用于完全二叉树。</p><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p><p>以下是我们的二叉链表的结点结构定义代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h3 id="二叉树遍历原理"><a href="#二叉树遍历原理" class="headerlink" title="二叉树遍历原理"></a>二叉树遍历原理</h3><p>二叉树的遍历（traversing biary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><h3 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h3><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h4><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h4><p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p><h4 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h4><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><h3 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的前序遍历递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span> <span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">  PreOrderTraverse (T-&gt;lchild); <span class="comment">/* 再先序遍历左子树 */</span></span><br><span class="line">  PreOrderTraverse (T-&gt;rchild); <span class="comment">/* 最后先序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的中序遍历递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span> <span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  InOrderTraverse (T-&gt;lchild); <span class="comment">/* 中序遍历左子树 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">  InOrderTraverse (T-&gt;rchild); <span class="comment">/* 最后中序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的后序遍历递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span> <span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  PostOrderTraverse (T-&gt;lchild); <span class="comment">/* 先后序遍历左子树 */</span></span><br><span class="line">  PostOrderTraverse (T-&gt;rchild); <span class="comment">/* 再后序遍历右子树 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h3><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知前序和后序遍历，是不能唯一确定一棵二叉树的。</li></ul><h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按前序输入二叉树中结点的值（一个字符） */</span></span><br><span class="line"><span class="comment">/* #表示空树，构造二叉链表表示二叉树 T。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span> <span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TElemType ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="keyword">if</span> (ch==<span class="string">'#'</span>)</span><br><span class="line">    *T=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (!*T)</span><br><span class="line">      <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    (*T)-&gt;data=ch; <span class="comment">/* 生成根结点 */</span></span><br><span class="line">    CreateBiTree(&amp;(*T)-&gt;lchild); <span class="comment">/* 构造左子树 */</span></span><br><span class="line">    CreateBiTree(&amp;(*T)-&gt;rchild); <span class="comment">/* 构造右子树 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</p><p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做是线索化。</p><h3 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">enum</span> <span class="params">(Link, Thread)</span> PointerTag</span>; <span class="comment">/* Link==0 表示指向左右孩子指针 Thread==1 表示指向前驱或后继的线索 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> /* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">  PointerTag LTag;</span><br><span class="line">  PointerTag RTag; <span class="comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>线索化的过程就是在遍历的过程中修改空指针的过程。</p><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>将树转换为二叉树的步骤如下</p><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ol><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>步骤如下：</p><ol><li>将每个树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol><h3 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h3><ol><li>加线。</li><li>去线。</li><li>层次调整。</li></ol><h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><ol><li>从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li><li>再将每棵分离的二叉树转换为树即可。</li></ol><h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历分为两种方式。</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li></ol><p>森林的遍历也分为两种方式：</p><ol><li>前序遍历</li><li>后序遍历</li></ol><h2 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h2><h3 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h3><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</p><p>树的路径长度就是从树根到每一个结点的路径长度之和。</p><p>带权路径长度 WPL 最小的二叉树称做赫夫曼树。</p><h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><p>一般地，设需要编码的字符集为{d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub>}，各个字符在电文中出现的次数或频率集合为 {w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub>}，以 d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub> 作为叶子结点，以 w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub> 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第6章-树&quot;&gt;&lt;a href=&quot;#第6章-树&quot; class=&quot;headerlink&quot; title=&quot;第6章 树&quot;&gt;&lt;/a&gt;第6章 树&lt;/h1&gt;&lt;p&gt;树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&amp;gt;1 时，其余结点可分为 m（m&amp;gt;0）个互不相交的有限集 T&lt;sub&gt;1&lt;/sub&gt;、T&lt;sub&gt;2&lt;/sub&gt;、……、T&lt;sub&gt;m&lt;/sub&gt;，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="http://chanceli.com/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="http://chanceli.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》四</title>
    <link href="http://chanceli.com/DataStructurePart4/"/>
    <id>http://chanceli.com/DataStructurePart4/</id>
    <published>2019-09-10T14:24:00.000Z</published>
    <updated>2020-03-22T12:26:36.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-串"><a href="#第5章-串" class="headerlink" title="第5章 串"></a>第5章 串</h1><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p><a id="more"></a><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><blockquote><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p></blockquote><h2 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h2><p>给定两个串：s= “a<sub>1</sub>a<sub>2</sub>……a<sub>n</sub>“,  t= “b<sub>1</sub>b<sub>2</sub>……b<sub>m</sub>“, 当满足以下条件之一时，s&lt;t。</p><ol><li>n&lt;m，且a<sub>i</sub>=b<sub>i</sub>（i=1, 2, ……, n）。</li><li>存在某个k&lt;min(m, n), 使得a<sub>i</sub>=b<sub>i</sub>（i=1，2，……，k-1）a<sub>k</sub>&lt;b<sub>k</sub></li></ol><h2 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串（string）</span><br><span class="line">Data</span><br><span class="line">  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。</span><br><span class="line">  StrCopy(T,S):串S存在，由串复制得串T。</span><br><span class="line">  ClearString(S):串S存在，将串清空。</span><br><span class="line">  StringEmpty(S):若串为空，返回true，否则返回false。</span><br><span class="line">  StrLength(S):返回串S的元素个数，即串的长度。</span><br><span class="line">  StrCompare(S,T):若S&gt;T，返回值&gt;0,若S=T，返回0，若S&lt;T，返回值&lt;0.</span><br><span class="line">  Concat(T,S1,S2):用T返回由S1和S2联接而成的新串。</span><br><span class="line">  SubString(Sub,S,pos,len):串S存在，1&lt;=pos&lt;=StrLength(S)，且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符长度为len的子串。</span><br><span class="line">  Index(S,T,pos):串S和T存在，T是非空串，1&lt;=pos&lt;=StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。</span><br><span class="line">  Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。</span><br><span class="line">  StrInsert(S,pos,T):串S和T存在，1&lt;=pos&lt;=StrLength(S)+1。在串S的第pos个字符之前插入串T。</span><br><span class="line">  StrDelete(S,pos,len):串S存在，1&lt;=pos&lt;=StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>Index 的实现算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(String S, String T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m,i;</span><br><span class="line">  String sub;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    n = StrLength(S);</span><br><span class="line">    m = StrLength(T);</span><br><span class="line">    i = pos;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= n-m+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      SubString(sub,S,i,m); <span class="comment">/* 取主串第i个位置 长度与T相等子串给sub */</span></span><br><span class="line">      <span class="keyword">if</span> (StrCompare(sub,T) != <span class="number">0</span>)  <span class="comment">/* 如果两串不相等 */</span></span><br><span class="line">        ++i;</span><br><span class="line">      <span class="keyword">else</span>  <span class="comment">/* 如果两串相等 */</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 若无子串与T相等，返回0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当中用到了 StrLength、SubString、StrCompare 等基本操作来实现。</p><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般使用定长数组来定义。</p><h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全。</p><p>串的链式存储结构除了在链接串与串操作时有一定方便外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p><h2 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h2><p>子串的定位操作通常称做串的模式匹配。<br>假设我们要从下面的主串S=“goodgoogle”中，找到T=“google这个子串的位置”。<br>简单的来说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。<br>最好的情况，时间复杂度为O(1)。<br>稍差一些的情况，时间复杂度为O(n+m)，其中n为主串长度，m为要匹配的子串长度。<br>根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。</p><h2 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h2><p>D.E.Knuth、J.H.Morris 和 V.R.Pratt 发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特-莫里斯-普拉特算法，简称 KMP 算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第5章-串&quot;&gt;&lt;a href=&quot;#第5章-串&quot; class=&quot;headerlink&quot; title=&quot;第5章 串&quot;&gt;&lt;/a&gt;第5章 串&lt;/h1&gt;&lt;p&gt;串（string）是由零个或多个字符组成的有限序列，又名叫字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="http://chanceli.com/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="http://chanceli.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》三</title>
    <link href="http://chanceli.com/DataStructurePart3/"/>
    <id>http://chanceli.com/DataStructurePart3/</id>
    <published>2019-09-08T14:58:00.000Z</published>
    <updated>2020-03-22T12:29:24.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-栈与队列"><a href="#第4章-栈与队列" class="headerlink" title="第4章 栈与队列"></a>第4章 栈与队列</h1><p>栈是限定仅在表尾进行插入和删除操作的线性表。<br>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p><a id="more"></a><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><blockquote><p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><p>我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。</p><p>栈的插入操作，叫做进栈，也称压栈、入栈。<br>栈的删除操作，叫做出栈，也有的叫弹栈。</p><h2 id="进栈出栈的变化形式"><a href="#进栈出栈的变化形式" class="headerlink" title="进栈出栈的变化形式"></a>进栈出栈的变化形式</h2><p>元素数量多个，出栈次序会有很多种可能。</p><h2 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  InitStack(*S):初始化操作，建立一个空栈S。</span><br><span class="line">  DestroyStack(*S):若栈存在，则销毁它。</span><br><span class="line">  ClearStack(*S):将栈清空。</span><br><span class="line">  StackEmpty(S):若栈为空，返回 <span class="literal">true</span> ，否则返回 <span class="literal">false</span>。</span><br><span class="line">  GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line">  Push(*S,e):若栈S存在，插入新元素e到栈S中并成为栈顶元素。</span><br><span class="line">  Pop(*S,e):删除栈S中的栈顶元素，并用e返回其值。</span><br><span class="line">  StackLength(S):返回栈S的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h2><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>栈的结构定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> init SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SElemType data[MAXSIZE]</span><br><span class="line">  <span class="keyword">int</span> top;     <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p><h3 id="栈的顺序存储结构——进栈操作"><a href="#栈的顺序存储结构——进栈操作" class="headerlink" title="栈的顺序存储结构——进栈操作"></a>栈的顺序存储结构——进栈操作</h3><p>进栈操作 push，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span> <span class="params">(SqStack *S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S-&gt;top == MAXSIZE - <span class="number">1</span>) <span class="comment">/* 栈满 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  S-&gt;top++;   <span class="comment">/* 栈顶指针增加一 */</span></span><br><span class="line">  S-&gt;data[S-&gt;top]=e;   <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="栈的顺序存储结构——出栈操作"><a href="#栈的顺序存储结构——出栈操作" class="headerlink" title="栈的顺序存储结构——出栈操作"></a>栈的顺序存储结构——出栈操作</h3><p>出栈操作 pop，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span> <span class="params">(SqStack *S, SElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e=S-&gt;data[S-&gt;top]; <span class="comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">  S-&gt;top--;   <span class="comment">/* 栈顶指针减一 */</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进栈和出栈没有涉及到任何循环语句，因此时间复杂度均是 O(1)。</p><h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><p>使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。</p><h2 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h2><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>链栈的结构代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkStackPtr top;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素 e 为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span> <span class="params">(LinkStack *S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  s-&gt;next = s-&gt;top;  <span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继 */</span></span><br><span class="line">  S-&gt;top = s;  <span class="comment">/* 将新的结点s赋值给栈顶指针 */</span></span><br><span class="line">  S-&gt;count++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h3><p>假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span> <span class="params">(LinkStack *S, SElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkStackPtr p;</span><br><span class="line">  <span class="keyword">if</span> (StackEmpty(*S))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S-&gt;top-&gt;data;</span><br><span class="line">  p=S-&gt;top;  <span class="comment">/* 将栈顶结点赋值给p */</span></span><br><span class="line">  S-&gt;top=S-&gt;top-&gt;next;  <span class="comment">/* 使得栈顶指针下移一位，指向后一结点 */</span></span><br><span class="line">  <span class="built_in">free</span>(p);  <span class="comment">/* 释放结点 p */</span></span><br><span class="line">  S-&gt;count--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链栈的进栈 push 和出栈 pop 操作没有任何循环操作，时间复杂度均为O(1)。<br>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p><h2 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h2><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。</p><h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><h3 id="斐波那切数列实现"><a href="#斐波那切数列实现" class="headerlink" title="斐波那切数列实现"></a>斐波那切数列实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> Fbi(i<span class="number">-1</span>) + Fbi(i<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, Fbi(i));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。<br>每个递归定义必须至少有一个条件，满足递归不再进行，即不再引用自身而是返回值退出。</p><h2 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h2><ol><li><p>将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。</p></li><li><p>将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</p></li></ol><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><blockquote><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p></blockquote><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><h2 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列（Queue）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前缀和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  InitQueue(*Q):初始化操作，建立一个空队列Q。</span><br><span class="line">  DestroyQueue(*Q):若队列Q存在，则销毁它。</span><br><span class="line">  ClearQueue(*Q):将队列Q清空。</span><br><span class="line">  QueueEmpty(*Q):若队列Q为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line">  EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line">  DeQueue(*Q,*e):删除队列Q中队头元素，并用e返回其值。</span><br><span class="line">  QueueLength(Q):返回队列Q的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><p>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p><h2 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>链队列的结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>  /* 节点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  /* 队列的链表结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></p><h3 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!s)  <span class="comment">/* 存储分配失败 */</span></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  Q-&gt;rear-&gt;next = s;  <span class="comment">/* 把拥有元素e新结点s赋值给原队尾节点的后继 */</span></span><br><span class="line">  Q-&gt;rear = s;  <span class="comment">/* 把当前的s设置为队尾结点，rear指向s */</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  p=Q-&gt;front-&gt;next;  <span class="comment">/* 将欲删除的队头结点暂存给p */</span></span><br><span class="line">  *e=p-&gt;data;  <span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">  Q-&gt;front-&gt;next=p-&gt;next;  <span class="comment">/* 将原队头结点后继p-&gt;next赋值给头结点后缀 */</span></span><br><span class="line">  <span class="keyword">if</span>(Q-&gt;rear==p)  <span class="comment">/* 若队头是队尾，则删除后将rear指向头结点 */</span></span><br><span class="line">    Q-&gt;rear=Q-&gt;front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第4章-栈与队列&quot;&gt;&lt;a href=&quot;#第4章-栈与队列&quot; class=&quot;headerlink&quot; title=&quot;第4章 栈与队列&quot;&gt;&lt;/a&gt;第4章 栈与队列&lt;/h1&gt;&lt;p&gt;栈是限定仅在表尾进行插入和删除操作的线性表。&lt;br&gt;队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="http://chanceli.com/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="http://chanceli.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】使用环信实现聊天遇到的一些坑</title>
    <link href="http://chanceli.com/imeasemob/"/>
    <id>http://chanceli.com/imeasemob/</id>
    <published>2019-08-26T07:47:00.000Z</published>
    <updated>2019-09-08T08:45:15.220Z</updated>
    
    <content type="html"><![CDATA[<p>使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。<br><a id="more"></a></p><h2 id="问题1-聊天页面环信工具栏向上偏移"><a href="#问题1-聊天页面环信工具栏向上偏移" class="headerlink" title="问题1 聊天页面环信工具栏向上偏移"></a>问题1 聊天页面环信工具栏向上偏移</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在聊天页面，点击输入框弹起键盘，点击<code>IQKeyboardManager</code>带的完成按钮或者点击空白页面收起键盘，反复操作多次后，会出现页面向上偏移，环信<code>UI</code>的工具栏移动到了页面最上边。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在聊天页面禁用<code>IQKeyboardManager</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    IQKeyboardManager *keyboardManager =  [IQKeyboardManager sharedManager];</span><br><span class="line">    keyboardManager.enable = <span class="literal">NO</span>;</span><br><span class="line">    keyboardManager.enableAutoToolbar = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    IQKeyboardManager *keyboardManager =  [IQKeyboardManager sharedManager];</span><br><span class="line">    keyboardManager.enable = <span class="literal">YES</span>;</span><br><span class="line">    keyboardManager.enableAutoToolbar = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题2-保存环信昵称头像到数据库失败"><a href="#问题2-保存环信昵称头像到数据库失败" class="headerlink" title="问题2 保存环信昵称头像到数据库失败"></a>问题2 保存环信昵称头像到数据库失败</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p>环信服务器不存储用户的昵称头像等用户数据。需要客户端自己来存储并展示在界面上。有几个时机是需要插入或更新一条包含昵称、头像的用户数据到数据库里，比如查看用户详情，在某个页面收到环信消息。我们服务器提供的查询用户信息接口返回的昵称和头像，之前是没有问题的，有一次出现了从用户信息界面进入聊天页面不显示昵称的问题。</p><h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p>经排查，接口返回的用户头像字段的值是<code>null</code>，由于客户端之前没有做空处理，导致插入或更新一条数据失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB Query: INSERT or REPLACE INTO t_huanxin (hxId,nickname,avatar) VALUES (?,?,?)</span><br><span class="line">Unknown error finalizing or resetting statement (19: NOT NULL constraint failed: t_huanxin.avatar)</span><br></pre></td></tr></table></figure></p><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>存储用户信息到本地数据库时增加安全判断。如果为空，就存入空字符串。避免插入或更新字段为<code>null</code>导致操作失败。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *nickname = dic[<span class="string">@"nickname"</span>]?:<span class="string">@""</span>;</span><br><span class="line"><span class="built_in">NSString</span> *avatar = dic[<span class="string">@"avatar"</span>]?:<span class="string">@""</span>;</span><br></pre></td></tr></table></figure></p><h2 id="问题3-聊天页面发送首条消息后下拉刷新出现两条重复消息"><a href="#问题3-聊天页面发送首条消息后下拉刷新出现两条重复消息" class="headerlink" title="问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息"></a>问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息</h2><h3 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a>问题描述：</h3><p>使用环信<code>Demo</code>发送消息，首条消息发送后，下拉刷新，单聊页面会有两条重复的消息。<br>操作步骤：1.点击单聊页面右上角的清空按钮，清空某个用户的消息。2.返回会话列表。3.首次进入该用户的单聊页面。4.发送首条消息。5.页面下拉刷新。6.出现了两条一摸一样的消息。</p><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMChatViewController</code>的<code>tableViewDidTriggerHeaderRefresh</code>方法中增加如下判断。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableViewDidTriggerHeaderRefresh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解决首条消息发送后下拉刷新出现两条重复消息的BUG 开始</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataArray.count &amp;&amp; <span class="keyword">self</span>.moreMsgId == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> tableViewDidFinishTriggerHeader:<span class="literal">YES</span> reload:<span class="literal">NO</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解决首条消息发送后下拉刷新出现两条重复消息的BUG 结束</span></span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题4-聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录"><a href="#问题4-聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录" class="headerlink" title="问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录"></a>问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录</h2><h3 id="问题描述：-3"><a href="#问题描述：-3" class="headerlink" title="问题描述："></a>问题描述：</h3><p><code>iOS</code>环信<code>Demo</code>聊天页面，发送语音，点击“按住录音”，发送了0秒的聊天记录。</p><h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMChatViewController</code>的<code>chatBarRecordAudioViewStopRecord:timeLength:</code>方法中增加对录音时长的判断。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)chatBarRecordAudioViewStopRecord:(<span class="built_in">NSString</span> *)aPath</span><br><span class="line">                              timeLength:(<span class="built_in">NSInteger</span>)aTimeLength</span><br><span class="line">&#123;</span><br><span class="line">    EMVoiceMessageBody *body = [[EMVoiceMessageBody alloc] initWithLocalPath:aPath displayName:<span class="string">@"audio"</span>];</span><br><span class="line">    body.duration = (<span class="keyword">int</span>)aTimeLength;</span><br><span class="line">    <span class="keyword">if</span> (body.duration == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"录音时长为0"</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"录制时间过短，不能发送"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _sendMessageWithBody:body ext:<span class="literal">nil</span> isUpload:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题5-聊天页面点击查看图片，图片右上角按钮显示Done"><a href="#问题5-聊天页面点击查看图片，图片右上角按钮显示Done" class="headerlink" title="问题5 聊天页面点击查看图片，图片右上角按钮显示Done"></a>问题5 聊天页面点击查看图片，图片右上角按钮显示<code>Done</code></h2><h3 id="问题描述：-4"><a href="#问题描述：-4" class="headerlink" title="问题描述："></a>问题描述：</h3><p>聊天页面，点击查看图片，图片右上角的按钮显示<code>Done</code>，而不是”完成“。</p><h3 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h3><p>直接全局搜索<code>Done</code>,把环信<code>UI</code>里的<code>Done</code>,替换成”完成“即可。</p><h2 id="问题6-如何实现推送消息内容自定义"><a href="#问题6-如何实现推送消息内容自定义" class="headerlink" title="问题6 如何实现推送消息内容自定义"></a>问题6 如何实现推送消息内容自定义</h2><h3 id="问题描述：-5"><a href="#问题描述：-5" class="headerlink" title="问题描述："></a>问题描述：</h3><p>不想使用环信默认的推送内容：”您有一条新消息”，或”xxx：消息内容”。想实现自定义的消息内容。</p><h3 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h3><p>发送消息扩展里添加字段<code>em_apns_ext</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">nickname:<span class="string">"王小二"</span>,</span><br><span class="line">avatar:<span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">em_apns_ext:&#123;<span class="string">"em_push_content"</span>:<span class="string">"自定义推送内容"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="http://docs-im.easemob.com/im/ios/apns/content" target="_blank" rel="noopener">环信 APNs 内容解析文档</a></p><h2 id="问题7-头像链接与路由短链冲突"><a href="#问题7-头像链接与路由短链冲突" class="headerlink" title="问题7 头像链接与路由短链冲突"></a>问题7 头像链接与路由短链冲突</h2><h3 id="问题描述：-6"><a href="#问题描述：-6" class="headerlink" title="问题描述："></a>问题描述：</h3><p>项目里点击推送通知到落地页采用了路由模式，有一个场景是需要我们自己服务器发推送点击通知栏跳转到聊天页面。路由短链类似：<code>page://chat?from=hxId_10086</code>,由于某些原因，需要带上昵称和头像，加上头像链接后，短链变成了<code>page://chat?from=hxId_10086&amp;avatar=http://www.baidu.com&amp;nickname=王小二</code>，<code>iOS</code> 解析短链的方法是先把短链字符串转成了<code>URL</code>，加了<code>avatar</code>参数之后，转换失败，导致无法跳转。</p><h3 id="解决方案：-6"><a href="#解决方案：-6" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>方案1：<br>由于短链中含有<code>URL</code>，其实违反了路由链接设计的初衷，可以把<code>avatar</code>的值用<code>AES</code>加密一下传输，避免出现链接。</li><li>方案2：<br>不把短链字符串转换成<code>URL</code>，直接处理短链，去解析。</li></ul><h2 id="问题8-小程序发的语音消息iOS无法播放"><a href="#问题8-小程序发的语音消息iOS无法播放" class="headerlink" title="问题8 小程序发的语音消息iOS无法播放"></a>问题8 小程序发的语音消息<code>iOS</code>无法播放</h2><h3 id="问题描述：-7"><a href="#问题描述：-7" class="headerlink" title="问题描述："></a>问题描述：</h3><p>小程序发过来的语音消息<code>iOS</code>无法播放。</p><h3 id="问题原因：-1"><a href="#问题原因：-1" class="headerlink" title="问题原因："></a>问题原因：</h3><p><code>Android</code>和<code>iOS</code>发的语音格式都是<code>AMR</code>，小程序发的语音格式是<code>MP3</code>，<code>iOS</code>收到音频后，会先调用<code>_convertAudioFile:</code>方法转换格式，该方法内部实现实现里有一行代码是判断路径是否是<code>MP3</code>文件的，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[EMAudioPlayerHelper isMP3File:retPath]</span><br></pre></td></tr></table></figure></p><p>这个判断方法有问题，发过来的是<code>MP3</code>，却判断不是<code>MP3</code>，接着音频被当成<code>AMR</code>去转换<code>WAV</code> ，转换音频格式失败，播放失败。</p><h3 id="解决方案：-7"><a href="#解决方案：-7" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMAudioPlayerHelper</code>类中的<code>startPlayerWithPath:model:completion:</code>方法中增加判断，如果含有<code>.mp3</code>，就不转换，直接去播放。不含<code>.mp3</code>，就照旧走<code>_convertAudioFile:</code>转换格式方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([aPath containsString:<span class="string">@".mp3"</span>]) &#123;</span><br><span class="line">   <span class="comment">//不转换</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   aPath = [<span class="keyword">self</span> _convertAudioFile:aPath];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// aPath = [self _convertAudioFile:aPath];</span></span><br></pre></td></tr></table></figure></p><h3 id="问题扩展："><a href="#问题扩展：" class="headerlink" title="问题扩展："></a>问题扩展：</h3><p><code>iOS</code>发的语音消息，<code>Web</code>/小程序收到后无法播放？<br><code>App</code>端发来的文件是<code>AMR</code>格式的，小程序需要下载的时候转成<code>MP3</code>格式去播放。转换方法如下：<br>参考链接：<a href="http://docs-im.easemob.com/im/web/basics/message#%E9%9F%B3%E9%A2%91%E6%B6%88%E6%81%AF" target="_blank" rel="noopener">环信 Web IM 音频消息文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。&lt;br&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://chanceli.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://chanceli.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="环信" scheme="http://chanceli.com/tags/%E7%8E%AF%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》二</title>
    <link href="http://chanceli.com/DataStructurePart2/"/>
    <id>http://chanceli.com/DataStructurePart2/</id>
    <published>2019-05-29T09:46:00.000Z</published>
    <updated>2019-09-04T06:58:25.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-线性表"><a href="#第3章-线性表" class="headerlink" title="第3章 线性表"></a>第3章 线性表</h1><p>线性表：零个或多个数据元素的有限序列。</p><a id="more"></a><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><blockquote><p>线性表(List):零个或多个数据元素的有限序列。</p></blockquote><p>线性表元素的个数 n (n&gt;=0) 定义为线性表的长度，当 n = 0时，称为空表。</p><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>ADT 线性表(List)<br>Data<br>​    线性表的数据对象集合为{a<sub>1</sub>,a<sub>2</sub>,……,a<sub>n</sub>},每个元素的类型均为DataType。其中，除第一个元素a<sub>1</sub>外，每一个元素有且只有一个直接前驱元素，除了最后一个元素a<sub>n</sub>外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</p><p>Operation</p><p>​    InitList (*L):初始化操作，建立一个空的线性表L。</p><p>​    ListEmpty(L)：若线性表为空，返回true，否则返回false。</p><p>​    ClearList(*L)：将线性表清空。</p><p>​    GetElem(L,i,*e)：在线性表L中的第i个位置元素值返回给e。</p><p>​    LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。</p><p>​    ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。</p><p>​    ListDelete(<em>L,i, </em>e)：删除线性表L中的第i个位置元素，并用e返回其值。</p><p>​    ListLength(L)：返回线性表L的元素个数。</p><p>endADT</p><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h3><blockquote><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>一维数组来实现顺序存储结构。</p><h3 id="数组长度与线性表长度区别"><a href="#数组长度与线性表长度区别" class="headerlink" title="数组长度与线性表长度区别"></a>数组长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度。线性表的长度是线性表中数据元素的个数。在任意时刻，线性表的长度应该小于等于数组的长度。</p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>存储器中每个存储单元都有自己的编号，这个编号称为地址。</p><p>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i-1)*c</p><p>存取的时间性能为O(1)。</p><h2 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h2><h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>只要i的数值在数组的下标范围内，就是把数组的第i-1下标的值返回即可。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表的长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置i处；</li><li>表长加1。</li></ul><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；</li><li>表长减1。</li></ul><p>插入和删除的时间复杂度，最好情况为O(1)，最坏情况为O(n)，平均时间复杂度为O(n)。</p><h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><p>优点：</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间。</li><li>可以快速地存取表中任一位置的元素。</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素。</li><li>当线性表长度变化较大时，难以确定存储空间的容量。</li><li>造成存储空间的”碎片”。</li></ul><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>​    为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为结点(Node)。</p><p>​    n个结点(a<sub>i</sub>的存储映像)链结成一个链表，即为线性表(a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。</p><p>​    链表中的第一个结点的存储位置叫做头指针。在单链表的第一个结点前附设一个结点，称为头结点。头结点的指针域存储指向第一个结点的指针。</p><h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>单链表中，我们在C语言中可用结构指针来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的单链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span> <span class="comment">/*定义LinkList*/</span></span><br></pre></td></tr></table></figure><h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获取链表第i个数据的算法思路：</p><ol><li>声明一个指针p指向链表的第一个结点，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，返回结点p的数据。</li></ol><h3 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h3><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>单链表第i个数据插入结点的算法思路：</p><ol><li>声明一指针p指向链表头结点，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，在系统中生成一个空节点s；</li><li>将数据元素e赋值给s-&gt;data;</li><li>单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s;</li><li>返回成功。</li></ol><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一指针p指向链表头指针，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q；</li><li>单链表的删除标准语句p-&gt;next = q-&gt;next;</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点。</li><li>返回成功。</li></ol><h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>头插法</p><p>尾插法</p><h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一节点p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<ul><li>将下一个结点赋值给q；</li><li>释放p；</li><li>将q赋值给p。</li></ul></li></ol><h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><p>存储分配方式</p><ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表中的元素。</li></ul><p>时间性能</p><ul><li>查找 顺序存储结构O(1) 单链表O(n)</li><li>插入和删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在显出某位置的指针后，插入和删除时间仅为O(1)</li></ul><p>空间性能</p><ul><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</li></ul><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。</p><p>静态链表优缺点</p><p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><p>缺点：</p><ul><li>没有解决连续存储分配带来的表长难以确定的问题。</li><li>失去了顺序存储结构随机性存取的特性。</li></ul><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-线性表&quot;&gt;&lt;a href=&quot;#第3章-线性表&quot; class=&quot;headerlink&quot; title=&quot;第3章 线性表&quot;&gt;&lt;/a&gt;第3章 线性表&lt;/h1&gt;&lt;p&gt;线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="http://chanceli.com/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="http://chanceli.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》一</title>
    <link href="http://chanceli.com/DataStructurePart1/"/>
    <id>http://chanceli.com/DataStructurePart1/</id>
    <published>2019-03-05T15:41:00.000Z</published>
    <updated>2019-09-04T06:58:05.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-数据结构绪论"><a href="#第1章-数据结构绪论" class="headerlink" title="第1章 数据结构绪论"></a>第1章 数据结构绪论</h1><a id="more"></a><ul><li>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</li><li>数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</li><li>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</li><li>数据对象：是性质相同的数据元素的集合，是数据的子集。</li><li>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</li></ul><h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><h4 id="1-逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种："><a href="#1-逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种：" class="headerlink" title="1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种："></a>1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种：</h4><ul><li>集合机构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ul><h4 id="2-物理结构：是指数据的逻辑结构在计算机中的存储形式。"><a href="#2-物理结构：是指数据的逻辑结构在计算机中的存储形式。" class="headerlink" title="2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。"></a>2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。</h4><ul><li>顺序存储结构：是把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</li><li>链式存储结构：是把数据元素存放在任意的存储单元里，这组单元可以是连续的，也可以是不连续的。</li></ul><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。<br>C语言中，按照取值的不同，可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数组组成的。</li></ul><p>抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。</p><h1 id="第2章-算法"><a href="#第2章-算法" class="headerlink" title="第2章 算法"></a>第2章 算法</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ol><li>输入输出</li><li>有穷性</li><li>确定性</li><li>可行性</li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高和存储量低</li></ol><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><ol><li>事后统计方法（不科学、不准确）</li><li>事前分析估算方法</li></ol><h2 id="函数的渐近式增长"><a href="#函数的渐近式增长" class="headerlink" title="函数的渐近式增长"></a>函数的渐近式增长</h2><p>函数的渐近增长：给定两个函数 f(n) 和 g(n), 如果存在一个整数N，使得对于所有的 n &gt; N, f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p><h2 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h2><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶存在且不是 1，则去除与这个项相乘的常数。<br>得到的结果就是大 O 阶。</li></ol><h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章-数据结构绪论&quot;&gt;&lt;a href=&quot;#第1章-数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 数据结构绪论&quot;&gt;&lt;/a&gt;第1章 数据结构绪论&lt;/h1&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="http://chanceli.com/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="http://chanceli.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="http://chanceli.com/CodingGuidelines/"/>
    <id>http://chanceli.com/CodingGuidelines/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-08-14T15:55:05.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ol><li>长的、描述性的方法和变量命名是好的命名方式。不要使用简写，除非是一些大家都知道的场景比如 VIP。不要使用 bgView，推荐使用 backgroundView。</li><li>见名知意。含义清楚，做好不加注释代码自我表述能力强。（前提是代码足够规范）</li><li>不要过分追求技巧，降低代码可读性。</li><li>删除没必要的代码。比如我们新建一个控制器，里面会有一些不会用到的代码，或者注释起来的代码，如果这些代码不需要，那就删除它，留着偷懒吗？下次需要自己手写。</li><li>在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。</li><li>尽量减少单例的使用。</li><li>提供一个统一的数据管理入口，不管是 MVC、MVVM、MVP 模块内提供一个统一的数据管理入口会使得代码变得更容易管理和维护。</li><li>除了 .m 文件中方法，其他的地方”{“不需要另起一行。<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)getGooodsList</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doHomework</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hungry) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.thirsty) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.tired) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    papapa.then.over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li>一个变量最好只有一个作用，切勿为了节省代码行数，觉得一个变量可以做多个用途。（单一原则）</li><li>方法内部如果有局部变量，那么局部变量应该靠近在使用的地方，而不是全部在顶部声明全部的局部变量。</li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol><li>1元运算符和变量之间不需要空格。例如：<code>++n</code></li><li>2元运算符与变量之间需要空格隔开。例如： <code>containerWidth = 0.3 * Screen_Width</code><br>当有多个运算符的时候需要使用括号来明确正确的顺序，可读性较好。例如：<code>2 &lt;&lt; (1 + 2 * 3 - 4)</code></li></ol><h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><ol><li><p>当有条件过多、过长的时候需要换行，为了代码看起来整齐些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//good</span><br><span class="line">if (condition1() &amp;&amp; </span><br><span class="line">    condition2() &amp;&amp; </span><br><span class="line">    condition3() &amp;&amp; </span><br><span class="line">    condition4()) &#123;</span><br><span class="line">  // Do something</span><br><span class="line">&#125;</span><br><span class="line">//bad</span><br><span class="line">if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4(）) &#123; // Do something &#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个代码块里面有个可能的情况时善于使用 return 来结束异常的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)doHomework</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hungry) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.thirsty) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.tired) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    papapa.then.over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个分支的实现都必须使用 {} 包含。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (self.hungry) self.eat() </span><br><span class="line">// good</span><br><span class="line">if (self.hungry) &#123;</span><br><span class="line">    self.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断的时候应该是变量在左，条件在右。 if ( currentCursor == 2 ) { //… }</p></li><li>switch 语句后面的每个分支都需要用大括号括起来。</li><li>switch 语句后面的 default 分支必须存在，除非是在对枚举进行 switch。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (menuType) &#123;  </span><br><span class="line">  case menuTypeLeft: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">   &#125;</span><br><span class="line">  case menuTypeRight: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">  case menuTypeTop: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">  case menuTypeBottom: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h1><ol><li>大写驼峰式命名。每个单词首字母大写。比如「申请记录控制器」ApplyRecordsViewController</li><li>每个类型的命名以该类型结尾。</li></ol><ul><li>ViewController：使用 ViewController 结尾。例子：ApplyRecordsViewController</li><li>View：使用 View 结尾。例子：分界线：boundaryView</li><li>NSArray：使用 s 结尾。比如商品分类数据源。categories</li><li>UITableViewCell：使用 Cell 结尾。比如 MyProfileCell</li><li>Protocol：使用 Delegate 或者 Datasource 结尾。比如 XQScanViewDelegate</li><li>Tool：工具类</li><li>代理类：Delegate</li><li>Service 类：Service</li></ul><h1 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h1><p>有时候我们需要为我们创建的类设置一些注释。我们可以在类的下面添加。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举的命名和类的命名相近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123;</span><br><span class="line">    UIControlContentVerticalAlignmentCenter  = 0,</span><br><span class="line">    UIControlContentVerticalAlignmentTop     = 1,</span><br><span class="line">    UIControlContentVerticalAlignmentBottom  = 2,</span><br><span class="line">    UIControlContentVerticalAlignmentFill    = 3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><ol><li>全部大写，单词与单词之间用 _ 连接。</li><li>以 K 开头。后面遵循大写驼峰命名。「不带参数」<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define HOME_PAGE_DID_SCROLL @&quot;com.xq.home.page.tableview.did.scroll&quot;</span><br><span class="line">#define KHomePageDidScroll @&quot;com.xq.home.page.tableview.did.scroll&quot;</span><br></pre></td></tr></table></figure></li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>书写规则，基本上就是 @property 之后空一格，括号，里面的 线程修饰词、内存修饰词、读写修饰词，空一格 类 对象名称 根据不同的场景选择合适的修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UITableView *tableView;</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL loading;   </span><br><span class="line">@property (nonatomic, weak) id&lt;#delegate#&gt; delegate;</span><br><span class="line">@property (nonatomic, copy) &lt;#returnType#&gt; (^&lt;#Block#&gt;)(&lt;#parType#&gt;);</span><br></pre></td></tr></table></figure></p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>单例适合全局管理状态或者事件的场景。一旦创建，对象的指针保存在静态区，单例对象在堆内存中分配的内存空间只有程序销毁的时候才会释放。基于这种特点，那么我们类似 UIApplication 对象，需要全局访问唯一一个对象的情况才适合单例，或者访问频次较高的情况。我们的功能模块的生命周期肯定小于 App 的生命周期，如果多个单例对象的话，势必 App 的开销会很大，糟糕的情况系统会杀死 App。如果觉得非要用单例比较好，那么注意需要在合适的场合 tearDown 掉。</p><p>单例的使用场景概括如下：</p><ul><li>控制资源的使用，通过线程同步来控制资源的并发访问。</li><li>控制实例的产生，以达到节约资源的目的。</li><li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</li></ul><h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>推荐以<code>_</code>开头，写在 .m 文件中。例如<code>NSString * _somePrivateVariable</code></p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ol><li>类的实例必须作为方法的参数之一。</li><li>对于一些连续的状态的，可以加一些 will（将要）、did（已经）</li><li>以类的名称开头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>方法与方法之间间隔一行</li><li>大量的方法尽量要以组的形式放在一起，比如生命周期函数、公有方法、私有方法、setter &amp;&amp; getter、代理方法..</li><li>方法最后面的括号需要另起一行。遵循 Apple 的规范</li><li>对于其他场景的括号，括号不需要单独换行。比如 if 后面的括号。</li><li>如果方法参数过多过长，建议多行书写。用冒号进行对齐。</li><li>一个方法内的代码最好保持在50行以内，一般经验来看如果一个方法里面的代码行数过多，代码的阅读体验就很差（别问为什么，做过重构代码行数很长的人都有类似的心情）</li><li>一个函数只做一个事情，做到单一原则。所有的类、方法设计好后就可以类似搭积木一样实现一个系统。</li><li>对于有返回值的函数，且函数内有分支情况。确保每个分支都有返回值。</li><li>函数如果有多个参数，外部传入的参数需要检验参数的非空、数据类型的合法性，参数错误做一些措施：立即返回、断言。</li><li>多个函数如果有逻辑重复的代码，建议将重复的部分抽取出来，成为独立的函数进行调用</li><li><p>方法如果有多个参数的情况下需要注意是否需要介词和连词。很多时候在不知道如何抉择测时候思考下苹果的一些 API 的方法命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//good</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//bad</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age andName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView :(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></li><li><p>.m 文件中的私有方法需要在顶部进行声明 </p></li><li>方法组之间也有个顺序问题。</li></ol><ul><li>在文件最顶部实现属性的声明、私有方法的声明（很多人省去这一步，问题不大，但是蛮多第三方的库都写了，看起来还是会很方便，建议书写）。</li><li>在生命周期的方法里面，比如 viewDidLoad 里面只做界面的添加，而不是做界面的初始化，所有的 view 初始化建议放在 getter 里面去做。往往 view 的初始化的代码长度会比较长、且一般会有多个 view 所以 getter 和 setter 一般建议放在最下面，这样子顶部就可以很清楚的看到代码的主要逻辑。</li><li>所有button、gestureRecognizer 的响应事件都放在这个区域里面，不要到处乱放。</li></ul><p>文件基本上就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">/*ViewController*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*View&amp;&amp;Util*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*model*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*NetWork InterFace*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*Vender*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - life cycle</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">self.title = @&quot;标准模版&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - public Method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - private method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - event response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDelegate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDataSource</span><br><span class="line"></span><br><span class="line">//...(多个代理方法依次往下写)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - getters and setters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><ol><li>单个文件的命名 文件资源的命名也需要一定的规范，形式为：<code>功能模块名_类别_功能_状态</code><br>@nx.png <a href="mailto:Setting_Button_search_selected@2x.png" target="_blank" rel="noopener">Setting_Button_search_selected@2x.png</a>、<a href="mailto:Setting_Button_search_selected@3x.png" target="_blank" rel="noopener">Setting_Button_search_selected@3x.png</a> <a href="mailto:Setting_Button_search_unselected@2x.png" target="_blank" rel="noopener">Setting_Button_search_unselected@2x.png</a>、<a href="mailto:Setting_Button_search_unselected@3x.png" target="_blank" rel="noopener">Setting_Button_search_unselected@3x.png</a></li><li>资源的文件夹命名 最好也参考 App 按照功能模块建立对应的实体文件夹目录，最后到对应的目录下添加相应的资源文件。</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li>对于类的注释写在当前类文件的顶部</li><li>对于属性的注释需要写在属性后面的地方。 <code>//**&lt;userId*/</code></li><li>对于 .h 文件中方法的注释，一律按快捷键 <code>command+option+/</code>。三个快捷键解决。按需在旁边对方法进行说明解释、返回值、参数的说明和解释 </li><li>对于 .m 文件中的方法的注释，在方法的旁边添加 //。 </li><li>注释符和注释内容需要间隔一个空格。 例如： // fetch goods list</li></ol><h2 id="版本规范"><a href="#版本规范" class="headerlink" title="版本规范"></a>版本规范</h2><p>采用 A.B.C 三位数字命名，比如：1.0.2，当有更新的情况下按照下面的依据</p><p>版本号示例<br>A.b.c属于重大内容的更新1.0.2 -&gt; 2.0.0<br>a.B.c属于小部分内容的更新1.0.2 -&gt; 1.1.1<br>a.b.C属于补丁更新1.0.2 -&gt; 1.0.3</p><p>原文链接：<a href="https://juejin.im/post/5c7c7e0cf265da2ddb298123" target="_blank" rel="noopener">有了这些你们团队的代码肯定规范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;长的、描述性的方法和变量命名是好的命名方式。不要使用简写，除非是一些大家都知道的场景比如 VIP。不要使用 bgView，推荐使用 backgroundView。&lt;/li&gt;
&lt;li&gt;见名知意。含义清楚，做好不加注释代码自我表述能力强。（前提是代码足够规范）&lt;/li&gt;
&lt;li&gt;不要过分追求技巧，降低代码可读性。&lt;/li&gt;
&lt;li&gt;删除没必要的代码。比如我们新建一个控制器，里面会有一些不会用到的代码，或者注释起来的代码，如果这些代码不需要，那就删除它，留着偷懒吗？下次需要自己手写。&lt;/li&gt;
&lt;li&gt;在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。&lt;/li&gt;
&lt;li&gt;尽量减少单例的使用。&lt;/li&gt;
&lt;li&gt;提供一个统一的数据管理入口，不管是 MVC、MVVM、MVP 模块内提供一个统一的数据管理入口会使得代码变得更容易管理和维护。&lt;/li&gt;
&lt;li&gt;除了 .m 文件中方法，其他的地方”{“不需要另起一行。
    
    </summary>
    
      <category term="代码规范" scheme="http://chanceli.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://chanceli.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>我曾七次鄙视我的灵魂（卡里.纪伯伦）</title>
    <link href="http://chanceli.com/SevenTimesHaveIDespisedMySoul/"/>
    <id>http://chanceli.com/SevenTimesHaveIDespisedMySoul/</id>
    <published>2018-12-21T10:09:00.000Z</published>
    <updated>2018-12-21T11:03:09.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Seven times have I despised my soul:</p><p>——Kahlil Gibran</p><a id="more"></a><p>The first time when I saw her being meek that she might attain height.</p><p>The second time when I saw her limping before the crippled.</p><p>The third time when she was given to choose between the hard and the easy, and she chose the easy.</p><p>The fourth time when she committed a wrong, and comforted herself that others also commit wrong.</p><p>The fifth time when she forbore for weakness, and attributed her patience to strength.</p><p>The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks.</p><p>And the seventh time when she sang a song of praise, and deemed it a virtue.</p></blockquote><h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>我曾七次鄙视我的灵魂</p><p>——卡里.纪伯伦</p><p>第一次，当它本可进取时，却故作谦卑；</p><p>第二次，当它在空虚时，用爱欲来填充；</p><p>第三次，在困难和容易之间，它选择了容易；</p><p>第四次，它犯了错，却借由别人也会犯错来宽慰自己；</p><p>第五次，它自由软弱，却把它认为是生命的坚韧；</p><p>第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；</p><p>第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Seven times have I despised my soul:&lt;/p&gt;
&lt;p&gt;——Kahlil Gibran&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://chanceli.com/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="诗和远方" scheme="http://chanceli.com/tags/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第7章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart7/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart7/</id>
    <published>2018-01-06T16:07:00.000Z</published>
    <updated>2019-09-08T09:20:16.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h3><a id="more"></a><h4 id="47-熟悉系统框架"><a href="#47-熟悉系统框架" class="headerlink" title="47.熟悉系统框架"></a>47.熟悉系统框架</h4><p>将一系列代码封装为动态库（dynamic library），并在其中放入描述其接口的头文件，这样做出来的东西就叫框架。有时为iOS平台构建的第三方框架所使用的是静态库（static library），这是因为iOS应用程序不允许在其中包含动态库。这些东西严格来讲并不是真正的框架，然而也经常视为框架。不过，所有iOS平台的系统框架仍然使用动态库。</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ul><li>许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。</li><li>很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。</li><li>请记住：用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应该掌握C语言的核心概念。</li></ul><h4 id="48-多用块枚举，少用for循环"><a href="#48-多用块枚举，少用for循环" class="headerlink" title="48.多用块枚举，少用for循环"></a>48.多用块枚举，少用for循环</h4><ul><li>for 循环</li><li>使用Objective-C 1.0 的 NSEnumerator来遍历</li><li>快速遍历</li><li>基于块的遍历方式<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateObjectsUsingBlock:(<span class="keyword">void</span>(^)(<span class="keyword">id</span> object, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop))block</span><br></pre></td></tr></table></figure></li></ul><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ul><li>遍历collection有四种方式。最基本的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新、最先进的方式是“块枚举法”。</li><li>“块枚举法”本身就能通过GCD来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。</li><li>若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。</li></ul><h4 id="49-对自定义其内存管理语义的collection使用无缝桥接"><a href="#49-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="49.对自定义其内存管理语义的collection使用无缝桥接"></a>49.对自定义其内存管理语义的collection使用无缝桥接</h4><p>__bridge</p><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ul><li>通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。</li><li>在CoreFoundation层面创建collection时，可以指定许多回调函数，将其转换成具备特殊内存管理予以的Objective-C collection。</li></ul><h4 id="50-构建缓存时选用NSCache而非NSDictionary"><a href="#50-构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="50.构建缓存时选用NSCache而非NSDictionary"></a>50.构建缓存时选用NSCache而非NSDictionary</h4><p>NSCache是线程安全的。而NSDictionary则绝对不具备此优势，意思就是：在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache。</p><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ul><li>实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。</li><li>可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”（hard limit），它们仅对NSCache起指导作用。</li><li>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。</li><li>如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</li></ul><h4 id="51-精简initialize与load的实现代码"><a href="#51-精简initialize与load的实现代码" class="headerlink" title="51.精简initialize与load的实现代码"></a>51.精简initialize与load的实现代码</h4><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ul><li>在加载阶段，如果累实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。</li><li>首次使用到某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。</li><li>load与initialize方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入“依赖环”（interdependency cycle）的几率。</li><li>无法在编译期设定的全局变量，可以放在initialize方法里初始化。</li></ul><h4 id="52-别忘了NSTimer会保留其目标对象"><a href="#52-别忘了NSTimer会保留其目标对象" class="headerlink" title="52.别忘了NSTimer会保留其目标对象"></a>52.别忘了NSTimer会保留其目标对象</h4><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ul><li>NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完成任务之后也会失效。</li><li>反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定户籍导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。</li><li>可以扩充NSTimer的功能，用“块”来打破保留环。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第7章-系统框架&quot;&gt;&lt;a href=&quot;#第7章-系统框架&quot; class=&quot;headerlink&quot; title=&quot;第7章 系统框架&quot;&gt;&lt;/a&gt;第7章 系统框架&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第6章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart6/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart6/</id>
    <published>2018-01-05T16:06:00.000Z</published>
    <updated>2019-09-08T09:20:51.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第6章-块与大中枢派发"><a href="#第6章-块与大中枢派发" class="headerlink" title="第6章 块与大中枢派发"></a>第6章 块与大中枢派发</h3><a id="more"></a><h4 id="37-理解“块”这一概念"><a href="#37-理解“块”这一概念" class="headerlink" title="37.理解“块”这一概念"></a>37.理解“块”这一概念</h4><ul><li>块是C、C++、Objective-C 中的词法闭包。</li><li>块可接受参数，也可返回值。</li><li>块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。</li></ul><h4 id="38-为常用的块类型创建-typedef"><a href="#38-为常用的块类型创建-typedef" class="headerlink" title="38.为常用的块类型创建 typedef"></a>38.为常用的块类型创建 typedef</h4><ul><li>以typedef重新定义块类型，可令块变量用起来更加简单。</li><li>定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。</li><li>不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的 typedef 中的块签名即可，无须改动其他typedef。</li></ul><h4 id="39-用-handler-块降低代码分散程度"><a href="#39-用-handler-块降低代码分散程度" class="headerlink" title="39.用 handler 块降低代码分散程度"></a>39.用 handler 块降低代码分散程度</h4><ul><li>在创建对象时，可以使用内联的 handler 块将相关业务逻辑一并声明。</li><li>在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起。</li><li>设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。</li></ul><h4 id="40-用块引用其所属对象时不要出现保留环"><a href="#40-用块引用其所属对象时不要出现保留环" class="headerlink" title="40.用块引用其所属对象时不要出现保留环"></a>40.用块引用其所属对象时不要出现保留环</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)p_requestCompleted &#123;</span><br><span class="line">    <span class="keyword">if</span> (_completionHandler) &#123;</span><br><span class="line">        _completionHandler(_downloadedData);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">self</span>.completionHandler = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要下载请求执行完毕，保留环就解除了，而获取器对象也将会在必要时为系统所回收。</p><ul><li>如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。</li><li>一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。</li></ul><h4 id="41-多用派发队列，少用同步锁"><a href="#41-多用派发队列，少用同步锁" class="headerlink" title="41.多用派发队列，少用同步锁"></a>41.多用派发队列，少用同步锁</h4><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><ol><li><p>同步块（synchronization block）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)synchronizedMethod &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">          <span class="comment">//Safe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>NSLock锁对象  NSRecursiveLock递归锁</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">- (<span class="keyword">void</span>)synchronizedMethod &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="comment">//Safe</span></span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>缺陷：</p><ul><li>在极端情况下，同步块会导致死锁。</li><li>效率不见得很高。</li><li>直接使用锁对象，一旦遇到死锁，就会非常麻烦。</li><li>用atomic来修饰属性，只能提供某种程度的线程安全，无法保证访问该对象时绝对是线程安全的。使用属性时，必然能从中获取到有效值，然而在同一线程上多次调用获取方法（getter），每次获取到的结果未必相同。在两次访问操作之间，其他线程可能会写入新的属性值。</li></ul><ol start="3"><li>GCD<br> 串行同步队列（serial synchronization queue）<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveObjectivec.syncQueue"</span>,<span class="literal">NULL</span>);</span><br><span class="line">- (<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">  __block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line"> <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class="line">      localSomeString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localSomeString;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class="line">          _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>思路是：把设置操作与获取操作都安排在序列化的队列里执行，这样的话，所有针对属性的访问操作就都同步了。全部加锁任务都在GCD中处理。<br>并发队列（concurrent queue）<br>栅栏（barrier）<br>在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来要处理的块是个栅栏块，那么久一直要等栅栏块执行过后，再按正常方式继续向下处理。</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ul><li>派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized 块或 NSLock 对象更简单。</li><li>将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。</li><li>使用同步队列及栅栏块，可以令同步行为更加高效。</li></ul><h4 id="42-多用GCD，少用-performSelector-系列方法"><a href="#42-多用GCD，少用-performSelector-系列方法" class="headerlink" title="42.多用GCD，少用 performSelector 系列方法"></a>42.多用GCD，少用 performSelector 系列方法</h4><ol><li>performSelector 可能内存泄漏<br> performSelector 调用了一个方法。编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用ARC的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</li><li>有局限性。</li></ol><ul><li>返回值只能是void或对象类型。</li><li>参数类型是id，所以只能传入对象。此外，最多只能接受两个参数。</li></ul><p>dispatch_sync<br>dispatch_async<br>dispatch_after</p><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ul><li>performSelector 系列方法在内存管理方面容易有疏忽。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。</li><li>performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都收到限制。</li><li>如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</li></ul><h4 id="43-掌握GCD及操作队列的使用时机"><a href="#43-掌握GCD及操作队列的使用时机" class="headerlink" title="43.掌握GCD及操作队列的使用时机"></a>43.掌握GCD及操作队列的使用时机</h4><h5 id="GCD与NSOperationQueue"><a href="#GCD与NSOperationQueue" class="headerlink" title="GCD与NSOperationQueue"></a>GCD与NSOperationQueue</h5><ul><li>操作队列在底层是用GCD来实现的。</li><li>GCD是纯C的API，而操作队列则是Objective-C的对象。</li><li>在GCD中，任务用块来表示，而块是一个轻量级的数据结构。预支相反，“操作”（operation）则是个更为重量级的Objective-C对象。</li></ul><h5 id="使用NSOperation及NSOperationQueue的好处："><a href="#使用NSOperation及NSOperationQueue的好处：" class="headerlink" title="使用NSOperation及NSOperationQueue的好处："></a>使用NSOperation及NSOperationQueue的好处：</h5><ul><li>取消某个操作。运行任务之前，可以在NSOperation对象上调用cancel方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若是不使用操作队列，而是把块安排在GCD队列，那就无法取消了。开发者可以在应用程序层自己来实现取消功能，不过这样做需要编写很多代码，而那些代码其实已经由操作队列实现好了。</li><li>指定操作间的依赖关系。</li><li>通过键值观察机制监控NSOperation对象的属性。如isCancelled、isFinished。如果想在某个任务变更其状态时得到通知，或是想用比GCD更为精细的方式来控制所要执行的任务，那么键值观察机制会很有用。</li><li>指定操作的优先级。GCD只有队列的优先级，没有任务的优先级。NSOpetation对象也有线程优先级，这决定了运行此操作的线程处在何种优先级上。GCD可以实现此功能，然而操作队列更简单，只需设置一个属性。</li><li>重用NSOperation对象。<br>系统的NSNotificationCenter API选用了操作队列而非派发队列，开发者可通过其中的方法来注册监听器，以便在发生相关事件时得到通知，而这个方法接受的参数是块，不是选择子。</li></ul><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ul><li>在解决多线程与任务管理问题时，派发队列并非唯一方案。</li><li>操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。</li></ul><h4 id="44-通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#44-通过-Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="44.通过 Dispatch Group 机制，根据系统资源状况来执行任务"></a>44.通过 Dispatch Group 机制，根据系统资源状况来执行任务</h4><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ul><li>一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。</li><li>通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。</li></ul><h4 id="45-使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#45-使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="45. 使用dispatch_once来执行只需运行一次的线程安全代码"></a>45. 使用dispatch_once来执行只需运行一次的线程安全代码</h4><h5 id="实现单例"><a href="#实现单例" class="headerlink" title="实现单例"></a>实现单例</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> EOCClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ul><li>经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过GCD所提供的 dispatch_once 函数，很容易就能实现此功能。</li><li>标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。</li></ul><h4 id="46-不要使用-dispatch-get-current-queue"><a href="#46-不要使用-dispatch-get-current-queue" class="headerlink" title="46.不要使用 dispatch_get_current_queue"></a>46.不要使用 dispatch_get_current_queue</h4><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ul><li>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试之用。</li><li>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。</li><li>dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第6章-块与大中枢派发&quot;&gt;&lt;a href=&quot;#第6章-块与大中枢派发&quot; class=&quot;headerlink&quot; title=&quot;第6章 块与大中枢派发&quot;&gt;&lt;/a&gt;第6章 块与大中枢派发&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第5章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart5/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart5/</id>
    <published>2018-01-04T16:05:00.000Z</published>
    <updated>2018-12-06T10:03:45.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h3><a id="more"></a><h4 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h4><ul><li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。</li><li>在对象的生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。</li></ul><h4 id="30-以ARC简化引用计数"><a href="#30-以ARC简化引用计数" class="headerlink" title="30.以ARC简化引用计数"></a>30.以ARC简化引用计数</h4><ul><li>有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可以省去类中许多“样板代码”。</li><li>ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。</li><li>由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则。</li><li>ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。</li></ul><h4 id="31-在dealloc方法中只释放引用并解除监听"><a href="#31-在dealloc方法中只释放引用并解除监听" class="headerlink" title="31.在dealloc方法中只释放引用并解除监听"></a>31.在dealloc方法中只释放引用并解除监听</h4><ul><li>在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观察”(KVO)或NSNotificationCenter等通知，不要做其他事情。</li><li>如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。</li><li>执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。</li></ul><h4 id="32-编写“异常安全代码”时留意内存管理问题"><a href="#32-编写“异常安全代码”时留意内存管理问题" class="headerlink" title="32.编写“异常安全代码”时留意内存管理问题"></a>32.编写“异常安全代码”时留意内存管理问题</h4><ul><li>捕获异常时，一定要注意将try块内所创立的对象清理干净。</li><li>在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。</li></ul><h4 id="33-以弱引用避免保留环"><a href="#33-以弱引用避免保留环" class="headerlink" title="33.以弱引用避免保留环"></a>33.以弱引用避免保留环</h4><ul><li>将某些引用设为weak，可避免出现“保留环”。</li><li>weak引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着ARC而引人的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</li></ul><h4 id="34-以“自动释放池块”降低内存峰值"><a href="#34-以“自动释放池块”降低内存峰值" class="headerlink" title="34.以“自动释放池块”降低内存峰值"></a>34.以“自动释放池块”降低内存峰值</h4><ul><li>自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。</li><li>合理运用自动释放池，可降低应用程序的内存峰值。</li><li>@autoreleasepool这种新式写法能创建出更为轻便的自动释放池。</li></ul><h4 id="35-用“僵尸对象”调试内存管理问题"><a href="#35-用“僵尸对象”调试内存管理问题" class="headerlink" title="35.用“僵尸对象”调试内存管理问题"></a>35.用“僵尸对象”调试内存管理问题</h4><ul><li>系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能。</li><li>系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。</li></ul><h4 id="36-不要使用retainCount"><a href="#36-不要使用retainCount" class="headerlink" title="36.不要使用retainCount"></a>36.不要使用retainCount</h4><ul><li>对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”（absolute retain count）都无法反应对象生命周期的全貌。</li><li>引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第5章-内存管理&quot;&gt;&lt;a href=&quot;#第5章-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第5章 内存管理&quot;&gt;&lt;/a&gt;第5章 内存管理&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第4章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart4/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart4/</id>
    <published>2018-01-03T16:04:00.000Z</published>
    <updated>2018-12-06T10:03:35.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第4章-协议与分类"><a href="#第4章-协议与分类" class="headerlink" title="第4章 协议与分类"></a>第4章 协议与分类</h3><a id="more"></a><h4 id="23-通过委托与数据源协议进行对象间通信"><a href="#23-通过委托与数据源协议进行对象间通信" class="headerlink" title="23.通过委托与数据源协议进行对象间通信"></a>23.通过委托与数据源协议进行对象间通信</h4><ul><li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。</li><li>将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。</li><li>当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称“数据源协议”（data source protocal）。</li><li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li></ul><h4 id="24-将类的实现代码分散到便于管理的数个分类之中"><a href="#24-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24.将类的实现代码分散到便于管理的数个分类之中"></a>24.将类的实现代码分散到便于管理的数个分类之中</h4><ul><li>使用分类机制把类的实现代码划分成易于管理的小块。</li><li>将应该视为“私有”的方法归入名叫Private的分类中，以隐藏实现细节。</li></ul><h4 id="25-总是为第三方类的分类名称加前缀"><a href="#25-总是为第三方类的分类名称加前缀" class="headerlink" title="25.总是为第三方类的分类名称加前缀"></a>25.总是为第三方类的分类名称加前缀</h4><ul><li>向第三方类中添加分类时，总应给其名称加上你专用的前缀。</li><li>向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。</li></ul><h4 id="26-勿在分类中声明属性"><a href="#26-勿在分类中声明属性" class="headerlink" title="26.勿在分类中声明属性"></a>26.勿在分类中声明属性</h4><ul><li>把封装数据所用的全部属性都定义在主接口里。</li><li>在“class-continuation分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。</li></ul><h4 id="27-使用“class-continuation分类”隐藏实现细节"><a href="#27-使用“class-continuation分类”隐藏实现细节" class="headerlink" title="27.使用“class-continuation分类”隐藏实现细节"></a>27.使用“class-continuation分类”隐藏实现细节</h4><ul><li>通过“class-continuation分类”向类中新增实例变量。</li><li>如果某属性在主接口中声明为“只读”，而类的内部又要用设置方法修改此属性，那么就在“class-continuation分类”中将其扩展为“可读写”。</li><li>把私有方法的原型声明在“class-continuation分类”里面。</li><li>若想使类所遵循的协议不为人所知，则可于“class-continuation分类”中声明。</li></ul><h4 id="28-通过协议提供匿名对象"><a href="#28-通过协议提供匿名对象" class="headerlink" title="28.通过协议提供匿名对象"></a>28.通过协议提供匿名对象</h4><ul><li>协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。</li><li>使用匿名对象来隐藏类型名称（或类名）。</li><li>如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第4章-协议与分类&quot;&gt;&lt;a href=&quot;#第4章-协议与分类&quot; class=&quot;headerlink&quot; title=&quot;第4章 协议与分类&quot;&gt;&lt;/a&gt;第4章 协议与分类&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第3章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart3/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart3/</id>
    <published>2018-01-02T16:03:00.000Z</published>
    <updated>2018-12-06T10:03:24.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第3章-接口与API设计"><a href="#第3章-接口与API设计" class="headerlink" title="第3章 接口与API设计"></a>第3章 接口与API设计</h3><a id="more"></a><h4 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h4><ul><li>选择与你的公司、应用程序或者二者皆有关联之名作为类名的前缀，并在所有代码中均使用这一前缀。</li><li>若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。</li></ul><h4 id="16-提供“全能初始化方法”"><a href="#16-提供“全能初始化方法”" class="headerlink" title="16.提供“全能初始化方法”"></a>16.提供“全能初始化方法”</h4><ul><li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。</li><li>若全能初始化方法与超类不同，则需覆写超类中的对应方法。</li><li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li></ul><h4 id="17-实现description方法"><a href="#17-实现description方法" class="headerlink" title="17.实现description方法"></a>17.实现description方法</h4><ul><li>实现description方法返回一个有意义的字符串，用以描述该实例。</li><li>若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription方法。</li></ul><h4 id="18-尽量使用不可变对象"><a href="#18-尽量使用不可变对象" class="headerlink" title="18.尽量使用不可变对象"></a>18.尽量使用不可变对象</h4><ul><li>尽量创建不可变的对象。</li><li>若某属性仅可用于对象内部修改，则在“class-continuation分类”中将其由readonly属性扩展为readwrite属性。</li><li>不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。</li></ul><h4 id="19-使用清晰而协调的命名方式"><a href="#19-使用清晰而协调的命名方式" class="headerlink" title="19.使用清晰而协调的命名方式"></a>19.使用清晰而协调的命名方式</h4><ul><li>起名时应遵从标准的Objective-C命名规范，这样创建出来的接口更容易为开发者所理解。</li><li>方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。</li><li>方法名里不要使用缩略后的类型名称。</li><li>给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。</li></ul><h4 id="20-为私有方法名加前缀"><a href="#20-为私有方法名加前缀" class="headerlink" title="20.为私有方法名加前缀"></a>20.为私有方法名加前缀</h4><ul><li>给私有方法的名称加上前缀，这样可以很容易的将其同公共方法区分开。</li><li>不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。</li></ul><h4 id="21-理解-Objective-C错误模型"><a href="#21-理解-Objective-C错误模型" class="headerlink" title="21.理解 Objective-C错误模型"></a>21.理解 Objective-C错误模型</h4><ul><li>只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。</li><li>在错误不那么严重的情况下，可以指派委托方法（delegate method）来处理错误，也可以把错误信息放在NSError对象里，经由“输出参数”返回给调用者。</li></ul><h4 id="22-理解-NSCopying协议"><a href="#22-理解-NSCopying协议" class="headerlink" title="22.理解 NSCopying协议"></a>22.理解 NSCopying协议</h4><ul><li>若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。</li><li>如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。</li><li>复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应尽量执行浅拷贝。</li><li>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第3章-接口与API设计&quot;&gt;&lt;a href=&quot;#第3章-接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;第3章 接口与API设计&quot;&gt;&lt;/a&gt;第3章 接口与API设计&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第2章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart2/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart2/</id>
    <published>2018-01-01T16:02:00.000Z</published>
    <updated>2019-09-22T09:42:06.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h3><a id="more"></a><h4 id="6-理解“属性”这一概念"><a href="#6-理解“属性”这一概念" class="headerlink" title="6.理解“属性”这一概念"></a>6.理解“属性”这一概念</h4><p>使用属性，编译器会自动编写访问这些属性所需要的方法，这个过程由编译器在编译期执行。除了生成方法代码外，编译器还会自动向类中添加适当类型的实例变量，并且在属性名前面加下划线。</p><p>可以使用 @synthesize 语法来指定实例变量的名字。</p><p>@dynamic 关键字会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。而且，在编译器访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。</p><p>属性特质</p><p>属性可以拥有的特质分为四类：原子性、读/写权限、内存管理语义、方法名</p><p>1.原子性</p><p>具备 atomic 特质的获取方法会通过锁定机制来确保其操作的原子性。也就是说，如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值，若是不加锁的话（nonatomic），那么当其中一个线程正在改写某属性值时，另外一个线程也许会突然闯入，把尚未修改好的属性值读取出来，发生这种情况时，线程读到的属性值可能不对。</p><p>开发 iOS 程序，属性都声明为 nonatomic。历史原因是：在 iOS 中使用同步锁的开销较大，会带来性能问题。并且并<strong>不能保证线程安全</strong>。例如，<strong>一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值</strong>。</p><p>2.读写/权限</p><p>readwrite readonly</p><p>3.内存管理语义</p><ul><li>assign  针对“纯量类型”的简单赋值操作。</li><li>strong 拥有关系。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</li><li>weak 非拥有关系。设置方法既不保留新值，也不释放旧值。此特性同 assign 类似，然而在属性所指的对象遭到销毁时，属性值也会清空（nil out）。</li><li>unsafe_unretained 语义和 assign 相同，但它适用于“对象类型”，非拥有关系，当目标对象遭到摧毁时，属性值不会自动清空，这一点与 weak 有区别。</li><li>copy 与 strong 类似。然而设置方法并不保留新值，而是将其拷贝（copy）。只要实现属性所用的对象是可变的（mutable），就应该在设置新属性值时拷贝一份。</li></ul><p>4.方法名</p><p><code>getter=&lt;name&gt;</code> 指定“获取方法”的方法名。例如 UISwitch 类中的 switch 是否打开的属性<code>@property (nonatomic, getter=isOn) BOOL on</code>;</p><p><code>setter=&lt;name&gt;</code> 指定“设置方法”的方法名。不常见。</p><p>若是自己来实现这些存取方法，那么应该保证其具备相关属性所声明的特质。例如，如果将某个属性声明为 copy，那么就应该在“设置方法”中拷贝相关对象，否则会误导该属性的使用者，而且还会令程序产生 bug。</p><p>在实现自定义初始化方法时，如果属性是 copy 修饰的，初始化方法中赋值时也要 copy 一下。</p><p>atomic 为什么不能保证线程安全？例：一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。</p><p>要点</p><ul><li>可以使用 @property 语法来定义对象中所封装的数据。</li><li>通过“特质”来指定存储数据所需的正确语义。</li><li>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。</li><li>开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。</li></ul><h4 id="7-在对象内部尽量直接访问实例变量"><a href="#7-在对象内部尽量直接访问实例变量" class="headerlink" title="7.在对象内部尽量直接访问实例变量"></a>7.在对象内部尽量直接访问实例变量</h4><p>在对象之外访问实例变量，总是应该通过属性来做。</p><p>通过属性访问与直接访问的区别</p><ul><li>直接访问实例变量不经过 Objective-C 的“方法派发”（method dispatch）步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li><li>直接访问实例变量，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。</li><li>如果直接访问实例变量，那么不会触发“键值观测”（Key-Value Observing,KVO）通知。</li><li>通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”和/或“设置方法”中新增断点，监控该属性的调用者及其访问时机。</li></ul><p>要点</p><ul><li><p>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写（set方法），（1）首要原因在于，这样做能够确保相关属性的“内存管理语义”得以贯彻。（2）为了触发 KVO。</p></li><li><p>在初始化方法和dealloc方法中，总是应该直接通过实例变量来读写数据。</p></li><li>使用懒加载时，需要通过属性来读取数据。（get方法）</li></ul><h4 id="8-理解“对象等同性”这一概念"><a href="#8-理解“对象等同性”这一概念" class="headerlink" title="8.理解“对象等同性”这一概念"></a>8.理解“对象等同性”这一概念</h4><p>== 比较的是两个指针本身，而不是所指的对象。<br>isEqual 比较的两个对象。</p><p>要点</p><ul><li><p>若想检测对象的等同性，请提供“isEqual:”与 hash 方法。</p></li><li><p>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</p></li><li>不要盲目地逐个检测每条属性，而是应该依照具体需求来制定监测方案。</li><li>编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</li></ul><h4 id="9-以“类族模式”隐藏实现细节"><a href="#9-以“类族模式”隐藏实现细节" class="headerlink" title="9.以“类族模式”隐藏实现细节"></a>9.以“类族模式”隐藏实现细节</h4><p>类族（class cluster）是一种很有用的模式（pattern），可以隐藏“抽象基类”（abstract base class）背后的实现细节。比如 UIButton 的类方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIButton</span>*)buttonWithType:(<span class="built_in">UIButtonType</span>)type;</span><br></pre></td></tr></table></figure><p>该方法所返回的对象，其类型取决于传入的按钮类型。然而，不管返回什么类型的对象，它们都继承自同一个基类：UIButton。这么做的意义在于：UIButton 类的使用者无需关心创建出来的按钮具体属于哪个子类，也不用考虑按钮的绘制方式等实现细节。</p><p>工厂模式（Factory pattern）是创建类族的办法之一。</p><p>要点</p><ul><li>类族模式可以把实现细节隐藏在一套简单的公共接口后面。</li><li>系统框架中经常使用类族。</li><li>从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。</li></ul><h4 id="10-在既有类中使用关联对象存放自定义数据"><a href="#10-在既有类中使用关联对象存放自定义数据" class="headerlink" title="10.在既有类中使用关联对象存放自定义数据"></a>10.在既有类中使用关联对象存放自定义数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">void</span>*key, id value, objc_AssociationPolicy policy)</span></span></span><br></pre></td></tr></table></figure><p>此方法以给定的键和策略为某对象设置关联对象值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">void</span>*key)</span></span></span><br></pre></td></tr></table></figure></p><p>此方法根据给定的键从某对象中获取相应的关联对象值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObject</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure></p><p>此方法移除指定对象的全部关联对象。</p><p>要点</p><ul><li>可以通过“关联对象”机制把两个对象连起来。</li><li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。</li><li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。</li></ul><h4 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11.理解objc_msgSend的作用"></a>11.理解objc_msgSend的作用</h4><p>void objc_msgSend(id self, SEL cmd, …)</p><p>这是个参数可变的函数，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择子（SEL是选择子的类型），后续参数就是消息中的那些参数，其顺序不变。选择子指的就是方法的名字。</p><p>objc_msgSend 函数会根据接收者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其“方法列表”（list of methods）,如果能找到与选择子名称相符的方法，就跳转到其实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发”（message forwarding）操作。</p><p>objc_msgSend 会将匹配结果缓存在“快速映射表”（fast map）里面，每个类都有这样一块缓存。</p><p>边界情况</p><ul><li>objc_msgSend_stret。如果待发送的消息要返回结构体，那么可交由此函数处理。</li><li>objc_msgSend_fpret。如果消息返回的是浮点数，那么可交由此函数处理。</li><li>objc_msgSendSuper。如果要给超类发消息，那么就交由此函数处理。</li></ul><p>要点</p><ul><li>消息由接收者、选择子及参数构成。给某对象发送消息也就相当于在该对象上调用方法。</li><li>发给某对象的全部消息都要由“动态消息派发系统”（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。</li></ul><h4 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12.理解消息转发机制"></a>12.理解消息转发机制</h4><p>动态方法解析</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>假如尚未实现的方法是类方法 resolveClassMethod:</p><p>备援接收者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure><p>通过此方案，我们可以用组合来模拟出多重继承（multiple inheritance）的某些特性。</p><p>完整的消息转发</p><p>首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中。此对象包含选择子、目标（target）及参数。在触发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span>*)invocation</span><br></pre></td></tr></table></figure><p>要点</p><ul><li>若对象无法响应某个选择子，则进入消息转发流程。</li><li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li><li>对象可以把其无法解读的某些选择子转交给其他对象来处理。</li><li>经过上述两步后，如果还是没办法处理选择子，那就启动完整的消息转发机制。</li></ul><h4 id="13-用“方法调配技术”调试“黑盒方法”"><a href="#13-用“方法调配技术”调试“黑盒方法”" class="headerlink" title="13.用“方法调配技术”调试“黑盒方法”"></a>13.用“方法调配技术”调试“黑盒方法”</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span></span><br></pre></td></tr></table></figure><p>此函数的两个参数表示待交换的两个方法实现，而方法实现则可通过下列函数获得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span><span class="params">(Class aClass, SEL aSelector)</span></span></span><br></pre></td></tr></table></figure><p>要点</p><ul><li>在运行期，可以向类中新增或替换选择子所对应的方法实现。</li><li>使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常使用此技术向原有实现中添加新功能。</li><li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li></ul><h4 id="14-理解“类对象”的用意"><a href="#14-理解“类对象”的用意" class="headerlink" title="14.理解“类对象”的用意"></a>14.理解“类对象”的用意</h4><p>Objective-C 对象的本质</p><p>每个 Objective-C 对象实例都是指向某块内存数据的指针。</p><p>描述 Objective-C 对象所用的数据结构定义在运行期程序库的头文件里，id 类型本身也定义在这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">  Class isa;</span><br><span class="line">&#125; *id;</span><br></pre></td></tr></table></figure><p>由此可见，每个对象结构体的首个成员是 Class 类的变量。该变量定义了对象所属的类。</p><p>Class 对象也定义在运行期程序库的头文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">  Class isa;</span><br><span class="line">  Class super_class;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">long</span> version;</span><br><span class="line">  <span class="keyword">long</span> info;</span><br><span class="line">  <span class="keyword">long</span> instance_size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此结构存放类的“元数据”（metadata）。此结构体的首个变量也是 isa 指针，这说明 Class 本身亦为 Objective-C 对象。结构体里还有个变量叫做 super_class，它定义了本类的超类。类对象所属的类型（也就是 isa 指针所指向的类型）是另外一个类，叫做“元类”（metaclass）,用来表述类对象本身所具备的元数据。“类方法”就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。</p><p><code>isMemberOfClass:</code> 能够判断出对象是否为某个特定类的实例，而<code>isKindOfClass:</code>则能够判断出对象是否为某类或其派生类的实例。</p><p>要点</p><ul><li>每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。</li><li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。</li><li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第2章-对象、消息、运行期&quot;&gt;&lt;a href=&quot;#第2章-对象、消息、运行期&quot; class=&quot;headerlink&quot; title=&quot;第2章 对象、消息、运行期&quot;&gt;&lt;/a&gt;第2章 对象、消息、运行期&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第1章）</title>
    <link href="http://chanceli.com/EffectiveObjectiveCPart1/"/>
    <id>http://chanceli.com/EffectiveObjectiveCPart1/</id>
    <published>2017-12-31T16:01:00.000Z</published>
    <updated>2019-09-18T15:10:23.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第1章-熟悉Objective-C"><a href="#第1章-熟悉Objective-C" class="headerlink" title="第1章 熟悉Objective-C"></a>第1章 熟悉Objective-C</h3><a id="more"></a><h4 id="1-了解Objective-C-语言的起源"><a href="#1-了解Objective-C-语言的起源" class="headerlink" title="1.了解Objective-C 语言的起源"></a>1.了解Objective-C 语言的起源</h4><p>Objective-C使用消息结构messaging structure，而非函数调用function calling。<br>消息结构：运行时所运行的代码是由运行环境决定的。运行时才会去查找所要执行的方法。<br>函数调用：编译器决定。<br>Objective-C是C语言的超集，使用动态绑定的消息结构，在运行时才会检查对象类型。接收到一条消息后，究竟该执行何种代码，由运行时环境而非编译器决定。<br>对象所占内存总是分配在堆上。</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ul><li>Objective-C 为C语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接受一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。</li><li>理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。</li></ul><h4 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2.在类的头文件中尽量少引入其他头文件"></a>2.在类的头文件中尽量少引入其他头文件</h4><p>@class的作用：<br>（1）可以将引入头文件的时机延后，只在确实有需要的时候才引入，可以减少类的使用者所需引入的头文件数量，减少编译时间。<br>（2）解决两个类相互引用的问题。相互引用会导致循环引用，两个类里有一个无法被正确编译。</p><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ul><li>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。</li><li>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</li></ul><h4 id="3-多用字面量语法，少用与之等价的方法"><a href="#3-多用字面量语法，少用与之等价的方法" class="headerlink" title="3.多用字面量语法，少用与之等价的方法"></a>3.多用字面量语法，少用与之等价的方法</h4><p>字面量语法简明扼要。<br>创建数组或字典时使用字面量语法能够尽早发现插入nil的问题。</p><p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的（immutable）​。若想要可变版本的对象，则需复制一份：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *<span class="keyword">mutable</span> = [@[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>]mutableCopy];</span><br></pre></td></tr></table></figure></p><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ul><li>应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。</li><li>应该通过取下标操作来访问数组下标或字典中的键所对应的元素。</li><li>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</li></ul><h4 id="4-多用类型常量，少用-define预处理命令"><a href="#4-多用类型常量，少用-define预处理命令" class="headerlink" title="4.多用类型常量，少用#define预处理命令"></a>4.多用类型常量，少用#define预处理命令</h4><ul><li>不要使用预处理指令定义常量。（1）这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。（2）如果被其他人重新定义了常量值，编译器不会报警告，这将导致常量值不一致。</li><li>在实现文件里使用static const来定义此类中使用的常量。由于此类常量不在全局符号表中，所以无须为其名称加前缀。</li><li>在头文件中使用extern来声明全局变量，并在实现文件中定义其值。这种常量会出现在全局符号表中，所以名称最好加上与之相关的类名做前缀。</li></ul><h4 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5.用枚举表示状态、选项、状态码"></a>5.用枚举表示状态、选项、状态码</h4><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ul><li>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。</li><li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将个选项值定义为2的幂，以便通过按位或操作将其组合起来。</li><li>用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据结构。这样做可以确保枚举类型是用开发者所选的底层数据结构实现出来的，而不会采用编译器所选的类型。</li><li>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第1章-熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第1章-熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第1章 熟悉Objective-C&quot;&gt;&lt;/a&gt;第1章 熟悉Objective-C&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="http://chanceli.com/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop总结</title>
    <link href="http://chanceli.com/RunloopSummary/"/>
    <id>http://chanceli.com/RunloopSummary/</id>
    <published>2017-04-25T16:00:00.000Z</published>
    <updated>2018-12-08T14:36:23.829Z</updated>
    
    <content type="html"><![CDATA[<p>Runloops是线程相关底层基础的一部分。它的本质和字面意思一样运行着的循环（事件处理的循环）。<br><a id="more"></a><br>作用：接受循环事件和安排线程的工作。<br>目的：让线程在有任务的时候忙于工作，而没有任务的时候处于休眠状态。</p><h4 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h4><p>Runloop运行循环<br>iOS中通常所说的Runloop指的是NSRunloop（Foundation框架）或者CFRunloopRef（CoreFoundation框架），CFRunloopRef是纯C的函数，而NSRunloop仅仅是CFRunloopRef的一层OC封装。</p><h4 id="RunLoop作用"><a href="#RunLoop作用" class="headerlink" title="RunLoop作用"></a>RunLoop作用</h4><ol><li>保持程序的持续运行。</li><li>处理App中的各种事件。（如：touches触摸事件、NSTimer定时器事件、Selector事件）</li><li>节省CPU资源，提高程序性能（有事情就做事情，没事情就休息，资源释放）</li><li>负责渲染屏幕上的所有UI。</li></ol><h4 id="RunLoop开启-amp-退出"><a href="#RunLoop开启-amp-退出" class="headerlink" title="RunLoop开启&amp;退出"></a>RunLoop开启&amp;退出</h4><p>在UIApplicationMain函数内部开启了一个和主线程相关的RunLoop (保证主线程不会被销毁)，导致 UIApplicationMain 不会返回，一直在运行中，也就保证了程序的持续运行。<br>Runloop 的退出条件：<br>App退出；线程关闭；设置最大时间到期。</p><h4 id="RunLoop和线程关系"><a href="#RunLoop和线程关系" class="headerlink" title="RunLoop和线程关系"></a>RunLoop和线程关系</h4><ol><li>每条线程都有唯一的一个与之对应的Runloop对象。</li><li>主线程的RunLoop已经自动创建，子线程的RunLoop需要主动创建。</li><li>RunLoop在第一次获取时创建，在线程结束时销毁。</li><li>Runloop对象是利用字典来进行存储，Key：线程  Value：线程对应的Runloop。</li></ol><h5 id="创建子线程对应的RunLoop"><a href="#创建子线程对应的RunLoop" class="headerlink" title="创建子线程对应的RunLoop"></a>创建子线程对应的RunLoop</h5><p>currentRunLoop</p><h4 id="RunLoop相关类"><a href="#RunLoop相关类" class="headerlink" title="RunLoop相关类"></a>RunLoop相关类</h4><ul><li>CFRunLoopRef: RunLoop本身</li><li>CFRunLoopModeRef: 运行模式</li><li>CFRunLoopSourceRef: 事件源</li><li>CFRunLoopTimerRef: Timer事件</li><li>CFRunLoopObserverRef: 观察者（监听者）</li></ul><ol><li><p>一条线程 对应一个 Runloop，Runloop 总是运行在某种特定的CFRunLoopModeRef（运行模式）下。</p></li><li><p>每个 Runloop 都可以包含若干个 Mode ，每个 Mode 又包含Source源 / Timer事件 / Observer观察者。</p></li><li><p>在 Runloop 中有多个运行模式，每次调用 RunLoop 的主函数<code>__CFRunloopRun()</code>时，只能指定其中一个 Mode（称 CurrentMode）运行， 如果需要切换 Mode，只能是退出 CurrentMode 切换到指定的 Mode 进入，目的以保证不同 Mode 下的 Source / Timer / Observer 互不影响。</p></li><li><p>Runloop 有效，mode 里面 至少 要有一个timer(定时器事件) 或者是source(源)。</p></li></ol><h5 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h5><ul><li>kCFRunLoopDefaultMode App的默认Mode，通常主线程是在这个Mode下运行。</li><li>UITrackingRunLoopMode 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动</li><li>UIInitializationRunLoopMode  在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li><li>GSEventReceiveRunLoopMode 接受系统事件的内部 Mode，通常用不到。</li><li>kCFRunLoopCommonModes 一种模式组合</li></ul><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><ul><li>Source0:非基于端口Port的事件（用于用户主动触发的事件，如：点击按钮或点击屏幕）。</li><li>Source：基于端口Port的事件（通过内核和其他线程互相发送消息）</li></ul><h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><p>NSTimer受RunLoop的Mode影响。GCD定时器不受RunLoop影响。</p><h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><p>消息循环中的监听器</p><h4 id="RunLoop休眠"><a href="#RunLoop休眠" class="headerlink" title="RunLoop休眠"></a>RunLoop休眠</h4><p>RunLoop 最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。 RunLoop 的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件 Darwin 中的 Mach 来完成的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Runloops是线程相关底层基础的一部分。它的本质和字面意思一样运行着的循环（事件处理的循环）。&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://chanceli.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="http://chanceli.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Runtime总结</title>
    <link href="http://chanceli.com/RuntimeSummary/"/>
    <id>http://chanceli.com/RuntimeSummary/</id>
    <published>2017-04-23T16:00:00.000Z</published>
    <updated>2018-12-08T14:34:14.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Runtime是什么？"><a href="#一、Runtime是什么？" class="headerlink" title="一、Runtime是什么？"></a>一、Runtime是什么？</h3><a id="more"></a><p>Runtime 运行时，就是系统在运行的时候的一些机制，其中最主要的是消息机制。<br>Runtime 基本是用C和汇编编写的。</p><h4 id="OC与C语言在函数调用上的区别："><a href="#OC与C语言在函数调用上的区别：" class="headerlink" title="OC与C语言在函数调用上的区别："></a>OC与C语言在函数调用上的区别：</h4><p>C语言：</p><ol><li>函数的调用在编译的时候就决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li><li>C语言在编译阶段调用未实现的函数就会报错。</li></ol><p>OC：</p><ol><li>函数的调用称为消息发送。属于动态调用过程。</li><li>在编译的时候并不能决定真正调用哪个函数。在编译阶段，可以调用任何函数，只要函数声明过。</li></ol><h3 id="二、与Runtime系统交互："><a href="#二、与Runtime系统交互：" class="headerlink" title="二、与Runtime系统交互："></a>二、与Runtime系统交互：</h3><h5 id="1-通过OC源代码"><a href="#1-通过OC源代码" class="headerlink" title="1. 通过OC源代码"></a>1. 通过OC源代码</h5><p>编译器会自动将OC代码转换成运行时代码，在运行时确定数据结构和函数。</p><h5 id="2-NSObject类定义的方法"><a href="#2-NSObject类定义的方法" class="headerlink" title="2. NSObject类定义的方法"></a>2. NSObject类定义的方法</h5><p>-class<br>-isKindOfClass  -isMemberOfClass<br>-respondsToSelector<br>-confirmsToProtocol<br>-methodForSelector  返回指定方法实现的地址</p><h5 id="3-直接调用-Runtime-库函数-Runtime-常用接口方法"><a href="#3-直接调用-Runtime-库函数-Runtime-常用接口方法" class="headerlink" title="3. 直接调用 Runtime 库函数(Runtime 常用接口方法)"></a>3. 直接调用 Runtime 库函数(Runtime 常用接口方法)</h5><p>object_getClass<br>@selector()<br>class_getClassMethod<br>class_getInstanceMethod<br>class_addMethod()<br>class_replaceMethod<br>method_exchangeImplementations<br>class_copyPropertyList<br>class_copyMethodList<br>class_copyProtocolList</p><h3 id="三、Runtime相关术语"><a href="#三、Runtime相关术语" class="headerlink" title="三、Runtime相关术语"></a>三、Runtime相关术语</h3><p>SEL<br>id<br>Class<br>Method<br>Ivar 成员变量<br>IMP 是一个函数指针，指向了方法的实现。<br>Cache</p><h3 id="四、消息发送和消息转发"><a href="#四、消息发送和消息转发" class="headerlink" title="四、消息发送和消息转发"></a>四、消息发送和消息转发</h3><h4 id="消息发送-objc-msgSend"><a href="#消息发送-objc-msgSend" class="headerlink" title="消息发送  objc_msgSend"></a>消息发送  objc_msgSend</h4><ol><li>通过isa指针找到所属类。</li><li>查找类的cache列表, 如果没有则下一步。</li><li>查找类的”方法列表”。</li><li>如果能找到与选择子名称相符的方法, 就跳至其实现代码。</li><li>找不到, 就沿着继承体系继续向上查找。</li><li>如果能找到与选择子名称相符的方法, 就跳至其实现代码。</li><li>找不到, 执行”消息转发”。</li></ol><h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><ol><li><p>动态方法解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure></li><li><p>其他接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure></li><li><p>消息签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure></li><li><p>完整的消息转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">// invocation : 封装了与那条尚未处理的消息相关的所有细节的对象</span><br></pre></td></tr></table></figure></li></ol><h3 id="五、Runtime应用"><a href="#五、Runtime应用" class="headerlink" title="五、Runtime应用"></a>五、Runtime应用</h3><ol><li>动态添加一个类（KVO的实现原理）</li><li>获取一个类的所有属性<br>（1）打印一个类的成员变量列表，属性列表，方法列表<br>（2）动态改变变量的值。<br>（3）在 NSObject 的分类中增加方法，判断是否有该属性，用于避免使用KVC赋值时崩溃。<br>（4）自动归档和解档<br>（5）字典转模型</li><li>动态交换方法<br>（1）交换方法<br>（2）替换系统方法<br>（3）实现多继承的效果</li><li>动态添加方法 performSelector<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolveInstanceMethod</span><br><span class="line">class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Runtime是什么？&quot;&gt;&lt;a href=&quot;#一、Runtime是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、Runtime是什么？&quot;&gt;&lt;/a&gt;一、Runtime是什么？&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://chanceli.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="http://chanceli.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://chanceli.com/MarkdownUsage/"/>
    <id>http://chanceli.com/MarkdownUsage/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-12-14T06:30:28.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Markdown常用语法</p></blockquote><a id="more"></a><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h1><h2 id="2-1-无序列表"><a href="#2-1-无序列表" class="headerlink" title="2.1 无序列表"></a>2.1 无序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure><h3 id="预览-1"><a href="#预览-1" class="headerlink" title="预览"></a>预览</h3><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><h2 id="2-2-有序列表"><a href="#2-2-有序列表" class="headerlink" title="2.2 有序列表"></a>2.2 有序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><h3 id="预览-2"><a href="#预览-2" class="headerlink" title="预览"></a>预览</h3><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h1><p>在引用的文字前面加上<code>&gt;</code>就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用的文本</span><br></pre></td></tr></table></figure><h3 id="预览-3"><a href="#预览-3" class="headerlink" title="预览"></a>预览</h3><blockquote><p>引用的文本</p></blockquote><h1 id="4-粗体和斜体、删除文本"><a href="#4-粗体和斜体、删除文本" class="headerlink" title="4. 粗体和斜体、删除文本"></a>4. 粗体和斜体、删除文本</h1><h2 id="4-1-粗体"><a href="#4-1-粗体" class="headerlink" title="4.1 粗体"></a>4.1 粗体</h2><p>用两个<code>*</code>包含一段文本即是粗体</p><h2 id="4-2-斜体"><a href="#4-2-斜体" class="headerlink" title="4.2 斜体"></a>4.2 斜体</h2><p>用一个<code>*</code>包含一段文本即是斜体</p><h2 id="4-3-删除文本"><a href="#4-3-删除文本" class="headerlink" title="4.3 删除文本"></a>4.3 删除文本</h2><p>用<code>~~</code>包含一段文本即是删除文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**粗体文本**</span><br><span class="line">*斜体文本*</span><br><span class="line">~~删除文本~~</span><br></pre></td></tr></table></figure></p><h3 id="预览-4"><a href="#预览-4" class="headerlink" title="预览"></a>预览</h3><p><strong>粗体文本</strong><br><em>斜体文本</em><br><del>删除文本</del></p><h1 id="5-代码引用"><a href="#5-代码引用" class="headerlink" title="5. 代码引用"></a>5. 代码引用</h1><h2 id="5-1-单行代码"><a href="#5-1-单行代码" class="headerlink" title="5.1 单行代码"></a>5.1 单行代码</h2><p>引用代码时，如果引用的语句只有一行，可以用<code>·</code>(英文输入状态下左上角~下边的点)将语句包起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Markdown`</span><br></pre></td></tr></table></figure></p><h3 id="预览-5"><a href="#预览-5" class="headerlink" title="预览"></a>预览</h3><p><code>Markdown</code></p><h2 id="5-2-多行代码"><a href="#5-2-多行代码" class="headerlink" title="5.2 多行代码"></a>5.2 多行代码</h2><p>引用多行代码时，使用<code>···</code>（英文输入状态下左上角~下边的点）置于这段代码的首行和末行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func printHello() &#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><h3 id="预览-6"><a href="#预览-6" class="headerlink" title="预览"></a>预览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func printHello() &#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-图片和链接"><a href="#6-图片和链接" class="headerlink" title="6. 图片和链接"></a>6. 图片和链接</h1><h2 id="6-1-图片"><a href="#6-1-图片" class="headerlink" title="6.1 图片"></a>6.1 图片</h2><p>使用<code>![图片名字](图片链接地址)</code></p><h2 id="6-2-链接"><a href="#6-2-链接" class="headerlink" title="6.2 链接"></a>6.2 链接</h2><p>使用<code>[链接名字](链接地址)</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![头像](https://chanceli.com/images/avatar-small.png)</span><br><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></table></figure><h3 id="预览-7"><a href="#预览-7" class="headerlink" title="预览"></a>预览</h3><p><img src="https://chanceli.com/images/avatar-small.png" alt="头像"><br><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><h1 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h1><p><code>***</code>或<code>---</code></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="预览-8"><a href="#预览-8" class="headerlink" title="预览"></a>预览</h3><hr><h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h1><p><code>---</code>上面表示表头，下面表示表身，<code>:</code>在左边表示居左，在两边表示居中，在右边表示居右，不写<code>:</code>的话表头默认居中，表身默认居左。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 居左表头1    | 居中表头2     | 居右表头3  |</span><br><span class="line">| :---------- |:---------:  | -----:    |</span><br><span class="line">| 第1行文本    | 第1行文本     | 第1行文本  |</span><br><span class="line">| 第2行文本    | 第2行文本     | 第2行文本  |</span><br><span class="line">| 第3行文本    | 第3行文本     | 第3行文本  |</span><br></pre></td></tr></table></figure><h3 id="预览-9"><a href="#预览-9" class="headerlink" title="预览"></a>预览</h3><table><thead><tr><th style="text-align:left">居左表头1</th><th style="text-align:center">居中表头2</th><th style="text-align:right">居右表头3</th></tr></thead><tbody><tr><td style="text-align:left">第1行文本</td><td style="text-align:center">第1行文本</td><td style="text-align:right">第1行文本</td></tr><tr><td style="text-align:left">第2行文本</td><td style="text-align:center">第2行文本</td><td style="text-align:right">第2行文本</td></tr><tr><td style="text-align:left">第3行文本</td><td style="text-align:center">第3行文本</td><td style="text-align:right">第3行文本</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Markdown常用语法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://chanceli.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://chanceli.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
